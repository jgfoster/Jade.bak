| package |
package := Package name: 'Jade System Browser'.
package paxVersion: 1;
	basicComment: ''.

package basicPackageVersion: '0.184'.


package classNames
	add: #JadeAutoSystemBrowserPresenter;
	add: #JadeFindClassDialog;
	add: #JadeSystemBrowser;
	add: #JadeSystemBrowserPresenter;
	add: #SUnitResultDialog;
	yourself.

package methodNames
	add: #JadeBrowserPresenter -> #newMethodPresenter;
	add: #JadeServer -> #_addMethodCategoryNamesToMethodFilters;
	add: #JadeServer -> #_isPackagePolicyEnabled;
	add: #JadeServer -> #_objectSecurityPolicyFor:;
	add: #JadeServer -> #_packagePolicy:includesSelector:forClass:;
	add: #JadeServer -> #_selectedClassOverridesSelector:;
	add: #JadeServer -> #_systemBrowserCommand;
	add: #JadeServer -> #class:includesSelector:;
	add: #JadeServer -> #compiledMethodAt:inClass:;
	add: #JadeServer -> #dictionaryAndSymbolOf:;
	add: #JadeServer -> #dictionaryAndSymbolOf:forUser:;
	add: #JadeServer -> #environment;
	add: #JadeServer -> #environment:;
	add: #JadeServer -> #historyOf:;
	add: #JadeServer -> #sbAddDictionary:;
	add: #JadeServer -> #sbAddMethodCategory:;
	add: #JadeServer -> #sbAddMissingAccessors:;
	add: #JadeServer -> #sbAddNameOf:;
	add: #JadeServer -> #sbAddPackage:;
	add: #JadeServer -> #sbAddRepository:;
	add: #JadeServer -> #sbBreak:;
	add: #JadeServer -> #sbBrowseClassReferences:;
	add: #JadeServer -> #sbBrowseGlobalReferences:;
	add: #JadeServer -> #sbBrowseImplementors:;
	add: #JadeServer -> #sbBrowseMethodHistory:;
	add: #JadeServer -> #sbBrowseMethodsContaining:;
	add: #JadeServer -> #sbBrowseMethodsWithPragma:;
	add: #JadeServer -> #sbBrowseSenders:;
	add: #JadeServer -> #sbChangeClassName:;
	add: #JadeServer -> #sbChangesInPackage:;
	add: #JadeServer -> #sbCheckUniqueClassName:;
	add: #JadeServer -> #sbClass:;
	add: #JadeServer -> #sbClassCategory:;
	add: #JadeServer -> #sbClassComment:;
	add: #JadeServer -> #sbClassesToDictionary:;
	add: #JadeServer -> #sbClassFrom:;
	add: #JadeServer -> #sbClassTemplate;
	add: #JadeServer -> #sbComparePackages:;
	add: #JadeServer -> #sbCopyMethodsFor:;
	add: #JadeServer -> #sbFileOutClass:;
	add: #JadeServer -> #sbFileOutDictionary:;
	add: #JadeServer -> #sbFileOutMethod:;
	add: #JadeServer -> #sbFindClass;
	add: #JadeServer -> #sbFindClassPackageMap;
	add: #JadeServer -> #sbFindSelectors:;
	add: #JadeServer -> #sbInstVarsOldParent:newParent:oldChild:;
	add: #JadeServer -> #sbListMethodPragmas;
	add: #JadeServer -> #sbLoadLatestVersionOfConfiguration:;
	add: #JadeServer -> #sbMethodCategory:;
	add: #JadeServer -> #sbMethodClass:;
	add: #JadeServer -> #sbMigrateAll:;
	add: #JadeServer -> #sbNextParagraph;
	add: #JadeServer -> #sbPostSaveClass:;
	add: #JadeServer -> #sbReadMethodFilter;
	add: #JadeServer -> #sbRecompileSubclassesOf:andCopyMethods:;
	add: #JadeServer -> #sbRemoveClasses;
	add: #JadeServer -> #sbRemoveDictionaries:;
	add: #JadeServer -> #sbRemoveGlobals;
	add: #JadeServer -> #sbRemoveHistory:;
	add: #JadeServer -> #sbRemoveKey:fromDictionary:;
	add: #JadeServer -> #sbRemoveMethodCategories:;
	add: #JadeServer -> #sbRemoveMethods:;
	add: #JadeServer -> #sbRemovePriorVersions;
	add: #JadeServer -> #sbRemoveRepository:;
	add: #JadeServer -> #sbRevertClass;
	add: #JadeServer -> #sbRunClassTests:;
	add: #JadeServer -> #sbRunMethodTests:;
	add: #JadeServer -> #sbSavePackage:;
	add: #JadeServer -> #sbSetHomeDictionary:;
	add: #JadeServer -> #sbUniqueVersionName:;
	add: #JadeServer -> #sbUnloadPackage:;
	add: #JadeServer -> #sbUpdateClassCategories;
	add: #JadeServer -> #sbUpdateClasses;
	add: #JadeServer -> #sbUpdateClassHierarchy;
	add: #JadeServer -> #sbUpdateClassInfo;
	add: #JadeServer -> #sbUpdateClassList;
	add: #JadeServer -> #sbUpdateDictionaries;
	add: #JadeServer -> #sbUpdateMethod:;
	add: #JadeServer -> #sbUpdateMethodBreakPointsFor:;
	add: #JadeServer -> #sbUpdateMethodCategories;
	add: #JadeServer -> #sbUpdateMethodFilter;
	add: #JadeServer -> #sbUpdateMethodFilterSelections;
	add: #JadeServer -> #sbUpdateMethodInheritedImplementationsOf:;
	add: #JadeServer -> #sbUpdateMethodPragmas;
	add: #JadeServer -> #sbUpdateMethods;
	add: #JadeServer -> #sbUpdateMethodsByCategories;
	add: #JadeServer -> #sbUpdateMethodsByPragmas;
	add: #JadeServer -> #sbUpdateMethodsByVariables;
	add: #JadeServer -> #sbUpdateMethodSelectionsIn:;
	add: #JadeServer -> #sbUpdateMethodStepPointsFor:;
	add: #JadeServer -> #sbUpdateMethodVariables;
	add: #JadeServer -> #sbUpdatePackage:;
	add: #JadeServer -> #sbUpdatePackages;
	add: #JadeServer -> #sbUpdatePackagesOrDictionaries;
	add: #JadeServer -> #sbUpdateSuperclass;
	add: #JadeServer -> #symbolList;
	add: #JadeServer -> #systemBrowser:;
	add: #JadeServer -> #systemBrowserA:;
	add: #JadeServer -> #systemBrowserUpdate;
	add: #JadeServer -> #writeList:;
	add: #JadeServer32bit -> #systemBrowser:;
	add: #JadeServer64bit -> #sbRemoveKey:fromDictionary:;
	add: #JadeServer64bit -> #systemBrowser:;
	add: #JadeServer64bit32 -> #dictionaryAndSymbolOf:;
	add: #JadeServer64bit32 -> #dictionaryAndSymbolOf:forUser:;
	add: #JadeServer64bit34 -> #sbUpdateMethodsByCategories;
	add: #JadeServer64bit3x -> #class:includesSelector:;
	add: #JadeServer64bit3x -> #compiledMethodAt:inClass:;
	add: #JadeServer64bit3x -> #environment;
	add: #JadeServer64bit3x -> #environment:;
	add: #JadeServer64bit3x -> #initialize;
	add: #JadeServer64bit3x -> #sbBrowseMethodsWithPragma:;
	add: #JadeServer64bit3x -> #sbClassComment:;
	add: #JadeServer64bit3x -> #sbFileOutMethod:;
	add: #JadeServer64bit3x -> #sbListMethodPragmas:;
	add: #JadeServer64bit3x -> #sbMethod:;
	add: #JadeServer64bit3x -> #sbUpdateMethodBreakPointsFor:;
	add: #JadeServer64bit3x -> #sbUpdateMethodPragmas;
	add: #JadeServer64bit3x -> #sbUpdateMethodsByCategories;
	add: #JadeServer64bit3x -> #sbUpdateMethodsByPragmas;
	add: #JadeServer64bit3x -> #sbUpdateMethodsByVariables;
	add: #JadeServer64bit3x -> #sbUpdateMethodStepPointsFor:;
	add: #JadeTextDocument -> #jadeBrowseClasses;
	add: #JadeToolsToolBarPresenter -> #browseClasses;
	yourself.

package binaryGlobalNames: (Set new
	yourself).

package globalAliases: (Set new
	yourself).

package setPrerequisites: (IdentitySet new
	add: '..\Core\Object Arts\Dolphin\IDE\Base\Development System';
	add: '..\Core\Object Arts\Dolphin\Base\Dolphin';
	add: '..\Core\Object Arts\Dolphin\MVP\Views\Cards\Dolphin Card Containers';
	add: '..\Core\Object Arts\Dolphin\MVP\Presenters\Prompters\Dolphin Choice Prompter';
	add: '..\Core\Object Arts\Dolphin\MVP\Views\Common Controls\Dolphin Common Controls';
	add: '..\Core\Object Arts\Dolphin\MVP\Dialogs\Common\Dolphin Common Dialogs';
	add: '..\Core\Object Arts\Dolphin\MVP\Views\Control Bars\Dolphin Control Bars';
	add: '..\Core\Object Arts\Dolphin\MVP\Models\List\Dolphin List Models';
	add: '..\Core\Object Arts\Dolphin\MVP\Presenters\List\Dolphin List Presenter';
	add: '..\Core\Object Arts\Dolphin\MVP\Base\Dolphin MVP Base';
	add: '..\Core\Object Arts\Dolphin\MVP\Presenters\Prompters\Dolphin Prompter';
	add: '..\Core\Object Arts\Dolphin\MVP\Views\Scintilla\Dolphin Scintilla View';
	add: '..\Core\Object Arts\Dolphin\MVP\Views\Sliding Tray\Dolphin Slidey-Inney-Outey Thing';
	add: '..\Core\Object Arts\Dolphin\MVP\Presenters\Text\Dolphin Text Presenter';
	add: '..\Core\Object Arts\Dolphin\MVP\Models\Tree\Dolphin Tree Models';
	add: '..\Core\Object Arts\Dolphin\MVP\Presenters\Tree\Dolphin Tree Presenter';
	add: '..\Core\Object Arts\Dolphin\MVP\Type Converters\Dolphin Type Converters';
	add: '..\Core\Object Arts\Dolphin\MVP\Models\Value\Dolphin Value Models';
	add: 'GemStone C Interface';
	add: 'GemStone Objects';
	add: 'GemStone Session';
	add: 'Jade Autocompletation';
	add: 'Jade Class Browser';
	add: 'Jade Inspector';
	add: 'Jade Method Browser';
	add: 'Jade Test Browser';
	add: 'Jade UI';
	add: 'Jade UI Base';
	add: 'JGF Dolphin';
	add: 'Monticello';
	yourself).

package!

"Class Definitions"!

JadeBrowserPresenter subclass: #JadeSystemBrowserPresenter
	instanceVariableNames: 'ancestorListPresenter breakPoints categoryListPresenter categoryVariableTabs classCategoryPresenter classCommentPresenter classDefinition classDefinitionPresenter classHierarchyPresenter classHierarchyTabs classListPresenter dictionaryListPresenter environment eventCount globalsPresenter globalsLabel historyList historyIndex ignoreNextSetFocusEvent instanceClassTabs inUpdate keystrokeTime methodCategory methodFilterTabs methodListPresenter methodSource methodSourcePresenter originalSourceLabel originalSourcePresenter overrideListPresenter packageDictionaryTabs packageInfoTab packageLabel packageListPresenter pragmaListPresenter readStream repositoryListPresenter selectedClassChanged selectedClassesAreTestCases selectedClassName selectedClassOop stepPoints sunitPresenter superclassListPresenter textAreaTabs unimplementedSelectors updateCount updateProcess variableListPresenter'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
JadeSystemBrowserPresenter subclass: #JadeAutoSystemBrowserPresenter
	instanceVariableNames: 'lastGsShape bottomArrangement'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
JadeValueDialog subclass: #JadeFindClassDialog
	instanceVariableNames: 'classListPresenter nameEntryPresenter availableClasses'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
JadeValueDialog subclass: #SUnitResultDialog
	instanceVariableNames: 'listPresenter'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
JadeShell subclass: #JadeSystemBrowser
	instanceVariableNames: 'cardsPresenter roundTripCount'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

"Global Aliases"!


"Loose Methods"!

!JadeBrowserPresenter methodsFor!

newMethodPresenter

	^JadeTextPresenter new.
! !
!JadeBrowserPresenter categoriesFor: #newMethodPresenter!public! !

!JadeServer methodsFor!

_addMethodCategoryNamesToMethodFilters

	classList do: [:each | methodFilters addAll: each categoryNames].
!

_isPackagePolicyEnabled

	^self _gsPackagePolicy notNil!

_objectSecurityPolicyFor: anObject

	^anObject segment.
!

_packagePolicy: aPackagePolicy includesSelector: aSymbol forClass: aClass

	^aPackagePolicy notNil and: [aPackagePolicy includesSelector: aSymbol for: aClass].
!

_selectedClassOverridesSelector: aSymbol

	^selectedClass superclass notNil and: [selectedClass superclass canUnderstand: aSymbol].
!

_systemBrowserCommand

	| list command |
	list := self _nextLineAsList asOrderedCollection.
	command := list removeFirst.
	command = 'addDictionary'				ifTrue: [^self sbAddDictionary: list].
	command = 'addMethodCategory' 		ifTrue: [^self sbAddMethodCategory: list].
	command = 'addMissingAccessors'		ifTrue: [^self sbAddMissingAccessors: list].
	command = 'addPackage' 				ifTrue: [^self sbAddPackage: list].
	command = 'addRepository'			ifTrue: [^self sbAddRepository: list].

	command = 'break' 					ifTrue: [^self sbBreak: list].
	command = 'browseClassReferences'		ifTrue: [^self sbBrowseClassReferences: list].
	command = 'browseGlobalReferences'		ifTrue: [^self sbBrowseGlobalReferences: list].
	command = 'browseImplementors'		ifTrue: [^self sbBrowseImplementors: list].
	command = 'browseMethodHistory'		ifTrue: [^self sbBrowseMethodHistory: list].
	command = 'browseMethodsContaining'	ifTrue: [^self sbBrowseMethodsContaining: list].
	command = 'browseMethodsWithPragma'	ifTrue: [^self sbBrowseMethodsWithPragma: list].
	command = 'browseSenders'			ifTrue: [^self sbBrowseSenders: list].

	command = 'changeClassName'			ifTrue: [^self sbChangeClassName: list].
	command = 'changesInPackage'			ifTrue: [^self sbChangesInPackage: list].
	command = 'checkUniqueClassName'		ifTrue: [^self sbCheckUniqueClassName: list].
	command = 'class' 					ifTrue: [^self sbClass: list].
	command = 'classCategory'				ifTrue: [^self sbClassCategory: list].
	command = 'classComment'			ifTrue: [^self sbClassComment: list].
	command = 'classesToDictionary'		ifTrue: [^self sbClassesToDictionary: list].
	command = 'comparePackages'			ifTrue: [^self sbComparePackages: list].

	command = 'fileOutClass'				ifTrue: [^self sbFileOutClass: list].
	command = 'fileOutDictionary'			ifTrue: [^self sbFileOutDictionary: list].
	command = 'fileOutMethod'			ifTrue: [^self sbFileOutMethod: list].
	command = 'findClass' 				ifTrue: [^self sbFindClass].
	command = 'findSelectors'				ifTrue: [^self sbFindSelectors: list].


	command = 'listMethodPragmas'			ifTrue: [^self sbListMethodPragmas: list].
	command = 'loadLatestVersion'			ifTrue: [^self sbLoadLatestVersionOfConfiguration: list].

	command = 'method' 					ifTrue: [^self sbSaveMethod: list].
	command = 'methodCategory'			ifTrue: [^self sbMethodCategory: list].
	command = 'methodClass'				ifTrue: [^self sbMethodClass: list].

	command = 'objectLog'				ifTrue: [^self sbObjectLog: list].

	command = 'postSaveClass'			ifTrue: [^self sbPostSaveClass: list].

	command = 'removeClasses'			ifTrue: [^self sbRemoveClasses].
	command = 'removeDictionaries'			ifTrue: [^self sbRemoveDictionaries: list].
	command = 'removeGlobals'			ifTrue: [^self sbRemoveGlobals].
	command = 'removeMethodCategories' 	ifTrue: [^self sbRemoveMethodCategories: list].
	command = 'removeMethods'			ifTrue: [^self sbRemoveMethods: list].
	command = 'removePriorVersions'		ifTrue: [^self sbRemovePriorVersions].
	command = 'removeRepository'			ifTrue: [^self sbRemoveRepository: list].
	command = 'revertClass'				ifTrue: [^self sbRevertClass].

	command = 'savePackage'				ifTrue: [^self sbSavePackage: list].
	command = 'setHomeDictionary'			ifTrue: [^self sbSetHomeDictionary: list].

	command = 'uniqueVersionName'		ifTrue: [^self sbUniqueVersionName: list].
	command = 'unloadPackage'			ifTrue: [^self sbUnloadPackage: list].
	command = 'update' 					ifTrue: [^self systemBrowserUpdate].

	self error: 'Unknown command: ' , command printString.
!

class: aClass includesSelector: aSelector

	^aClass includesSelector: (self _decodeString: aSelector) asSymbol.
!

compiledMethodAt: aSymbol inClass: aClass

	^aClass compiledMethodAt: aSymbol.
!

dictionaryAndSymbolOf: aClass

	^self symbolList dictionaryAndSymbolOf: aClass.
!

dictionaryAndSymbolOf: aClass forUser: aUserProfile

	^aUserProfile symbolList dictionaryAndSymbolOf: aClass.
!

environment
	"Ignored prior to 3.x"

	^0!

environment: anInteger
	"Ignored prior to 3.x"!

historyOf: aClass

	| history |
	(history := aClass classHistory) isNil ifTrue: [
		history := Array with: aClass.
	].
	^history.
!

sbAddDictionary: anOrderedCollection

	| currentName newName symbolList index |
	symbolList := self symbolList.
	newName := anOrderedCollection removeFirst.
	anOrderedCollection notEmpty ifTrue: [
		currentName := anOrderedCollection removeFirst asSymbol.
		index := symbolList findFirst: [:each | each name = currentName].
	] ifFalse: [
		index := symbolList size + 1.
	].
	symbolList
		createDictionaryNamed: newName
		at: index.
	self _refreshSymbolList.
	selections at: #'dictionary' put: newName.
	self systemBrowserUpdate.
!

sbAddMethodCategory: anOrderedCollection

	(self sbClassFrom: anOrderedCollection) addCategory: anOrderedCollection first.
	selections at: #'methodCategory' put: anOrderedCollection first.
	self systemBrowserUpdate.
!

sbAddMissingAccessors: anOrderedCollection

	(self sbClassFrom: anOrderedCollection) compileMissingAccessingMethods.
	self systemBrowserUpdate.
!

sbAddNameOf: aClass

	writeStream nextPutAll: aClass name.
	1 < (self historyOf: aClass) size ifTrue: [
		writeStream nextPutAll: ' ('.
		((self historyOf: aClass) indexOf: aClass) printOn: writeStream.
		writeStream nextPut: $/.
		(self historyOf: aClass) size printOn: writeStream.
		writeStream nextPut: $).
	].
	writeStream tab.
!

sbAddPackage: anOrderedCollection

	| string |
	string := anOrderedCollection removeFirst.
	selections at: #'package' put: string.
	self mcWorkingCopyClass forPackage: (self _mcPackageClass named: string).
	self systemBrowserUpdate.
!

sbAddRepository: list

	| description repository packages |
	description := list removeFirst.
	repository := self mcRepositoryGroup repositories detect: [:each | each description = description].
	packages := self mcWorkingCopyClass allManagers select: [:each | list includes: each package name].
	packages do: [:each | each repositoryGroup addRepository: repository].
	self systemBrowserUpdate.
!

sbBreak: anOrderedCollection

	| myClass gsMethod stepPoint |
	myClass := self sbClassFrom: anOrderedCollection.
	gsMethod := self compiledMethodAt: anOrderedCollection removeFirst asSymbol inClass: myClass.
	stepPoint := anOrderedCollection removeFirst asNumber.
	anOrderedCollection removeFirst = 'set' ifTrue: [
		gsMethod setBreakAtStepPoint: stepPoint.
	] ifFalse: [
		gsMethod clearBreakAtStepPoint: stepPoint.
	].
	self systemBrowserUpdate.
!

sbBrowseClassReferences: anOrderedCollection

	| class |
	class := (self sbClassFrom: anOrderedCollection) thisClass.
	writeStream 
		nextPutAll: 'browseClassReferences'; lf;
		nextPutAll: (self _referencesToObject: class); 
		yourself.
!

sbBrowseGlobalReferences: anOrderedCollection

	| global |
	global := self _objectForOop: anOrderedCollection removeFirst asNumber.
	writeStream 
		nextPutAll: 'browseGlobalReferences'; lf;
		nextPutAll: (self _referencesToObject: global); 
		yourself.
!

sbBrowseImplementors: anOrderedCollection

	writeStream 
		nextPutAll: 'browseImplementors'; lf;
		nextPutAll: (self _implementorsOf: anOrderedCollection removeFirst);
		yourself.
!

sbBrowseMethodHistory: anOrderedCollection

	| behavior selector historyClass historyList |
	historyClass := self objectInBaseNamed: #'MethodVersionHistory'.
	historyClass isNil ifTrue: [^self].
	behavior := self sbClassFrom: anOrderedCollection.
	selector := anOrderedCollection removeFirst asSymbol.
	historyList := historyClass uniqueInstance 
		versionsOfMethod: selector 
		in: behavior.
	writeStream nextPutAll: 'browseMethodHistory'; nextPut: Character lf.
	historyList do: [:each | " behavior selector changeStamp category source"
		writeStream
			nextPutAll: each category; tab;
			nextPutAll: each changeStamp; tab;
			nextPutAll: each source;
			nextPut: Character lf;
			nextPut: $%;
			nextPut: Character lf;
			yourself.
	].
!

sbBrowseMethodsContaining: anOrderedCollection

	writeStream 
		nextPutAll: 'browseMethodsContaining'; lf;
		nextPutAll: (self methodsContaining: anOrderedCollection removeFirst);
		yourself.
!

sbBrowseMethodsWithPragma: anOrderedCollection

	writeStream 
		nextPutAll: 'browseMethodsWithPragma'; lf;
		yourself.
!

sbBrowseSenders: anOrderedCollection

	writeStream 
		nextPutAll: 'browseSenders'; lf;
		nextPutAll: (self _sendersOf: anOrderedCollection removeFirst);
		yourself.
!

sbChangeClassName: aList

	| oldName class newName changedIn |
	oldName := aList removeFirst asSymbol.
	class := self _objectForOop: aList removeFirst asNumber.
	class name == oldName ifFalse: [self error: 'Current name is ' , class name printString].
	newName := aList removeFirst asSymbol.
	class changeNameTo: newName.
	changedIn := OrderedCollection new.
	self symbolList do: [:each | 
		(each includes: class) ifTrue: [
			(each at: oldName ifAbsent: [nil]) == class ifFalse: [self error: 'Class not at name!!'].
			(each includesKey: newName) ifTrue: [self error: 'Key already in use!!'].
			each
				removeKey: oldName;
				at: newName put: class;
				yourself.
			changedIn add: each.
		].
	].
	self systemBrowserUpdate.
!

sbChangesInPackage: anOrderedCollection

	| current repository patch string |
	current := self mcWorkingCopyClass forPackage: (self _mcPackageClass named: anOrderedCollection removeFirst).
	repository := anOrderedCollection removeFirst.
	repository := current repositoryGroup repositories detect: [:each | each description = repository].
	patch := current changesRelativeToRepository: repository.
	patch operations isEmpty ifTrue: [current modified: false].
	string := self 
		_mcDescriptionOfPatch: patch
		baseName: 'closest ancestor'
		alternateName: nil.
	writeStream 
		nextPutAll: 'changesInPackage'; lf;
		nextPutAll: string;
		yourself.
!

sbCheckUniqueClassName: aList

	| oldName class newName |
	oldName := aList removeFirst asSymbol.
	class := self _objectForOop: aList removeFirst asNumber.
	class name == oldName ifFalse: [
		writeStream nextPutAll: 'Current name is ' , class name printString. 
		^self.
	].
	newName := aList removeFirst asSymbol.
	self symbolList do: [:each | 
		((each includes: class) and: [each includesKey: newName]) ifTrue: [
			writeStream nextPutAll: 'Dictionary '.
			each name printOn: writeStream.
			writeStream nextPutAll: ' already has a global with name '.
			newName printOn: writeStream.
			^self.
		].
	].
	!

sbClass: aList

	| string newClass mcWorkingCopyClass packages dictName |
	string := aList first.
	newClass := string evaluate.
	self classOrganizer update.
	(mcWorkingCopyClass := self mcWorkingCopyClass) isNil ifTrue: [
		packages := Array with: nil.
	] ifFalse: [
		packages := mcWorkingCopyClass allManagers collect: [:each | each package name].
		packages := packages select: [:each | (newClass category copyFrom: 1 to: (newClass category size min: each size)) = each].
		packages isEmpty ifTrue: [
			packages := Array with: nil.
		].
	].
	dictName := (newClass class canUnderstand: #'symbolDictionaryName')
		ifTrue: [newClass symbolDictionaryName]
		ifFalse: [
			| array |
			array := self dictionaryAndSymbolOf: newClass.
			array isNil
				ifTrue: ['UserGlobals']
				ifFalse: [array first name]].
	selections 
		at: #'package' 		put: packages first;
		at: #'dictionary' 		put: dictName asString;
		at: #'category' 		put: newClass category;
		at: #'className'	put: newClass name;
		at: #'class'				put: newClass;
		yourself.
	selectedClass := newClass.
	self systemBrowserUpdate.
!

sbClassCategory: aList

	| category classes |
	category := aList removeFirst.
	category := category copyFrom: 1 to: category size - 1.
	classes := aList removeFirst subStrings reject: [:each | each isEmpty].
	classes := classes collect: [:each | self objectNamed: each asSymbol].
	classes := classes collect: [:each | each thisClass].
	classes do: [:each | each category: category].
	self systemBrowserUpdate.
!

sbClassComment: anOrderedCollection

	| class doc txt |
	class := (self sbClassFrom: anOrderedCollection) thisClass.
	doc := (self objectInBaseNamed: #'GsClassDocumentation') newForClass: self.
	txt := (self objectInBaseNamed: #'GsDocText') new details: self sbNextParagraph trimSeparators.
	doc documentClassWith: txt.
	class description: doc.
	self systemBrowserUpdate.
!

sbClassesToDictionary: anOrderedCollection

	| action targetName target sourceNames sources classNames |
	action := anOrderedCollection removeFirst.
	targetName := anOrderedCollection removeFirst asSymbol.
	target := self symbolList detect: [:each | each name = targetName].
	sourceNames := self _nextLineAsList collect: [:each | each asSymbol].
	sources := sourceNames collect: [:eachName | self symbolList detect: [:eachDictionary | eachDictionary name = eachName]].
	classNames := self _nextLineAsList collect: [:each | each asSymbol].
	classNames do: [:eachName | 
		| source class |
		source := sources detect: [:eachDict | 
			class := eachDict detect: [:eachGlobal | eachGlobal isBehavior and: [eachGlobal name = eachName]] ifNone: [nil].
			class notNil.
		].
		target at: class name put: class.
		action = 'move' ifTrue: [source removeKey: class name].
	].
	self systemBrowserUpdate.
!

sbClassFrom: anOrderedCollection

	| selectedClassName selectedClassOop set myClass |
	selectedClassName := (anOrderedCollection removeFirst subStrings: Character space) first.
	selectedClassOop := anOrderedCollection removeFirst asNumber.
	set := IdentitySet new.
	self symbolList do: [:eachDict | 
		eachDict do: [:eachGlobal |
			eachGlobal isBehavior ifTrue: [
				set addAll: (self historyOf: eachGlobal).
			].
		].
	].
	myClass := set detect: [:each | (self oopOf: each) = selectedClassOop].
	myClass name asString = selectedClassName ifFalse: [self error: 'Class not found!!'].
	anOrderedCollection removeFirst = 'classTab' ifTrue: [myClass := myClass class].
	^myClass.
!

sbClassTemplate

	| string index |
	string := Stream definition.
	index := string findPattern: #('Stream') startingAt: 1.
	writeStream 
		nextPutAll: '0'; lf;	"selectedClassOop"
		nextPut: $(; lf;
		nextPutAll: (string copyFrom: 1 to: index - 1);
		nextPutAll: 'MyNewClass';
		nextPutAll: (string copyFrom: index + 6 to: string size);
		nextPutAll: ')';
		nextPutAll: ((string includesString: 'category: ''')
			ifTrue: ['']
			ifFalse: [' category: ' , Boolean category printString]); lf;
		nextPut: $%; lf;
		nextPut: $%; lf;
		yourself.
!

sbComparePackages: anOrderedCollection

	| current ancestor repository patch string |
	current := self mcWorkingCopyClass forPackage: (self _mcPackageClass named: anOrderedCollection removeFirst).
	ancestor := anOrderedCollection removeFirst.
	repository := anOrderedCollection removeFirst.
	repository := current repositoryGroup repositories detect: [:each | each description = repository].
	ancestor := repository class name = #'MCDictionaryRepository'
		ifTrue: [repository versionFromVersionNamed: ancestor]
		ifFalse: [repository versionFromFileNamed: ancestor , '.mcz'].
	patch := current package snapshot patchRelativeToBase: ancestor snapshot.
	string := self 
		_mcDescriptionOfPatch: patch
		baseName: ancestor info name
		alternateName: nil.
	writeStream 
		nextPutAll: 'comparePackages'; lf;
		nextPutAll: string;
		yourself.
!

sbCopyMethodsFor: newClass

	| history oldClass symbolList |
	newClass isMeta ifFalse: [self sbCopyMethodsFor: newClass class].
	history := self historyOf: newClass thisClass.
	oldClass := history at: history size - 1.
	newClass isMeta ifTrue: [oldClass := oldClass class].
	symbolList := self symbolList.
	oldClass selectors do: [:each | 
		| source category errors |
		source := (self compiledMethodAt: each inClass: oldClass) sourceString.
		category := self _behavior: oldClass categoryOfSelector: each.
		errors := newClass 
			compileMethod: source
			dictionaries: symbolList
			category: category.
		errors notNil ifTrue: [
			writeStream
				nextPutAll: 'compileError'; lf;
				nextPutAll: newClass name; tab;
				nextPutAll: category; lf;
				nextPutAll: source; lf;
				nextPut: $%; lf;
				yourself.
			newClass removeSelector: each ifAbsent: [].
		].
	].
!

sbFileOutClass: anOrderedCollection

	writeStream nextPutAll: (self sbClassFrom: anOrderedCollection) thisClass fileOutClass.
!

sbFileOutDictionary: anOrderedCollection

	| dictionary |
	dictionary := self objectNamed: anOrderedCollection first.
	writeStream nextPutAll: '!! ------- Create dictionary if it is not present
run
| aSymbol names userProfile |
aSymbol := ' , dictionary name printString , '.
userProfile := System myUserProfile.
names := userProfile symbolList names.
(names includes: aSymbol) ifFalse: [
	| symbolDictionary |
	symbolDictionary := SymbolDictionary new name: aSymbol; yourself.
	userProfile insertDictionary: symbolDictionary at: names size + 1.
].
' , '%
'.
	self classOrganizer
		fileOutClassesAndMethodsInDictionary: dictionary
		on: writeStream.
!

sbFileOutMethod: anOrderedCollection

	| aClass |
	aClass := (self sbClassFrom: anOrderedCollection) thisClass.
	writeStream nextPutAll: (aClass fileOutMethod: anOrderedCollection removeFirst).
!

sbFindClass

	| classToPackageMap |
	classToPackageMap := self sbFindClassPackageMap.
	self symbolList do: [:eachDict | 
		| name |
		name := eachDict name.
		eachDict do: [:eachGlobal | 
			eachGlobal isBehavior ifTrue: [
				| category |
				category := eachGlobal category.
				category isNil ifTrue: [category := ''].
"1"			self sbAddNameOf: eachGlobal.
			writeStream
"2"				nextPutAll: name; tab;
"3"				nextPutAll: category; tab;		"Class category"
"4"				nextPutAll: (classToPackageMap at: eachGlobal ifAbsent: ['']); tab;		"Package name if available"
				lf.
			].
		].
	].
!

sbFindClassPackageMap

	| systemOrganizerClass mcWorkingCopyClass dictionary packageInfoList |
	dictionary := Dictionary new.
	(systemOrganizerClass := self objectInBaseNamed: #'SystemOrganizer') isNil ifTrue: [^dictionary].
	(mcWorkingCopyClass := self mcWorkingCopyClass) isNil ifTrue: [^dictionary].
	packageInfoList := mcWorkingCopyClass allManagers collect: [:each | each packageInfo].
	systemOrganizerClass new categoryDict keysAndValuesDo: [:catName :classes |
		| symbol packageInfo |
		symbol := catName asSymbol.
		packageInfo := packageInfoList detect: [:each | each includesSystemCategory: symbol] ifNone: [nil].
		packageInfo notNil ifTrue: [
			| name |
			name := packageInfo name.
			classes do: [:each | dictionary at: each put: name].
		].
	].
	^dictionary.
!

sbFindSelectors: anOrderedCollection

	| allSymbols pattern |
	pattern := (anOrderedCollection collect: [:each | each = '*' ifTrue: [$*] ifFalse: [each]]) asArray.
	allSymbols := ((AllUsers userWithId: #SymbolUser ifAbsent: [AllUsers userWithId: #DataCurator]) resolveSymbol: #AllSymbols) value.
	allSymbols := allSymbols select: [:each |each asUppercase matchPattern: pattern].
	allSymbols := allSymbols select: [:each | (self classOrganizer implementorsOf: each) notEmpty].
	allSymbols := allSymbols asSortedCollection.
	allSymbols do: [:each | writeStream nextPutAll: each; nextPut: Character lf; yourself].
!

sbInstVarsOldParent: oldParent newParent: newParent oldChild: oldChild

	| added removed newList used missing |
	added := newParent allInstVarNames asIdentitySet - oldParent allInstVarNames asIdentitySet.
	removed := oldParent allInstVarNames asIdentitySet - newParent allInstVarNames asIdentitySet.
	newList := oldChild instVarNames.
	used := IdentitySet new.
	(oldChild class canUnderstand: #'_methodDict') ifTrue: [
		oldChild _methodDict do: [:each | used addAll: each instVarsAccessed].
	].
	(oldChild class canUnderstand: #'persistentMethodDictsDo:') ifTrue: [
		oldChild persistentMethodDictsDo: [:eachDict | 
			eachDict do: [:eachMethod | 
				used addAll: eachMethod instVarsAccessed.
			].
		].
	].
	used := used * removed.	"Only interested in things that have been removed."
	missing := (used - newList asIdentitySet) asSortedCollection asArray.
	newList := newList , missing.
	newList := newList reject: [:each | added includes: each].
	^newList.
!

sbListMethodPragmas
	"Private - none before 3x"
!

sbLoadLatestVersionOfConfiguration: anOrderedCollection

	anOrderedCollection do: [:each | 
		(self objectNamed: each) project latestVersion load.
	].
	self systemBrowserUpdate.
!

sbMethodCategory: anOrderedCollection

	| behavior category |
	behavior := self sbClassFrom: anOrderedCollection.
	category := anOrderedCollection removeFirst.
	anOrderedCollection do: [:each | 
		behavior 
			_moveMethod: each asSymbol
			toCategory: category.
	].
	self systemBrowserUpdate.
!

sbMethodClass: anOrderedCollection
	"Private - Drag/drop method onto class"

	| action list set sourceBehavior target targetName targetVersion |
	sourceBehavior := self sbClassFrom: anOrderedCollection.
	action := anOrderedCollection removeFirst.
	targetName := anOrderedCollection removeFirst.
	list := targetName subStrings.
	targetName := list first asSymbol.
	1 < list size ifTrue: [
		targetVersion := list at: 2.
		targetVersion := targetVersion copyFrom: 2 to: targetVersion size - 1.
		targetVersion := (targetVersion subStrings: $/) collect: [:each | each asNumber].
	].
	set := IdentitySet new.
	self symbolList do: [:eachDict | 
		eachDict do: [:eachGlobal | 
			(eachGlobal isBehavior and: [eachGlobal name = targetName]) ifTrue: [set add: eachGlobal].
		].
	].
	1 < set size ifTrue: [self error: 'Target name is ambiguous!!'].
	1 = set size ifFalse: [self error: 'Target not found!!'].
	target := set asArray first.
	targetVersion notNil ifTrue: [
		target classHistory size ~~ (targetVersion at: 2) ifTrue: [self error: 'Target not found with proper version history!!'].
		target := target classHistory at: (targetVersion at: 1).
	].
	sourceBehavior isMeta ifTrue: [target := target class].
	anOrderedCollection do: [:each | 
		| gsMethod result |
		gsMethod := self compiledMethodAt: each asSymbol inClass: sourceBehavior.
		result := self		"key: GsNMethod value: (Array withAll: errors and warnings)"
				compileMethod: gsMethod sourceString
				behavior: target
				symbolList: self symbolList 
				inCategory: (self _behavior: sourceBehavior categoryOfSelector: gsMethod selector).
		(result key notNil and: [action = 'move']) ifTrue: [
			sourceBehavior removeSelector: gsMethod selector.
		].
	].
	self systemBrowserUpdate.
!

sbMigrateAll: aClass

	| mcPlatformSupport classes instances |
	((mcPlatformSupport := self objectInBaseNamed: #'MCPlatformSupport') notNil and: [mcPlatformSupport autoMigrate]) ifTrue: [^self].
	System commitTransaction ifFalse: [self error: 'commit failed!!'].
	classes := (ClassOrganizer new allSubclassesOf: aClass) 
		inject: (IdentitySet withAll: (self historyOf: aClass))
		into: [:set :each | set addAll: (self historyOf: each); yourself].
	classes := classes asArray.
	instances := (self objectInBaseNamed: #'SystemRepository') listInstances: classes.
	1 to: classes size do: [:i | 
		| class |
		class := classes at: i.
		class 
			migrateInstances: (instances at: i) 
			to: (self historyOf: class) last.
		System commitTransaction ifFalse: [self error: 'commit failed!!'].
	].
!

sbNextParagraph

	| stream |
	stream := self _writeStreamOnString.
	[
		readStream peek = $%.
	] whileFalse: [
		stream nextPutAll: self _nextLine; lf.
	].
	self _nextLine.
	^stream contents.
!

sbPostSaveClass: anOrderedCollection

	| newClass copyMethods recompileSubclasses migrateInstances removeFromClassHistory |
	newClass := (self sbClassFrom: anOrderedCollection) thisClass.
	copyMethods := anOrderedCollection removeFirst = 'true'.
	recompileSubclasses := anOrderedCollection removeFirst = 'true'.
	migrateInstances := anOrderedCollection removeFirst = 'true'.
	removeFromClassHistory := anOrderedCollection removeFirst = 'true'.
	copyMethods ifTrue: [self sbCopyMethodsFor: newClass].
	recompileSubclasses ifTrue: [self sbRecompileSubclassesOf: newClass andCopyMethods: copyMethods].
	migrateInstances ifTrue: [self sbMigrateAll: newClass].
	removeFromClassHistory ifTrue: [self sbRemoveHistory: newClass].
	self systemBrowserUpdate.
!

sbReadMethodFilter

	| pieces |
	pieces := self _nextLine subStrings: Character tab.
	methodFilterType := pieces at: 1.
	writeStream 
		nextPutAll: methodFilterType; tab;
		nextPutAll: self environment printString; 
		lf.
!

sbRecompileSubclassesOf: newClass andCopyMethods: aBoolean

	| history oldClass list |
	history := self historyOf: newClass thisClass.
	oldClass := history at: history size - 1.
	list := self classOrganizer subclassesOf: oldClass.
	list do: [:oldSubclass |
		| instVars classInstVars definition string newSubclass i j |
		instVars := self sbInstVarsOldParent: oldClass newParent: newClass oldChild: oldSubclass.
		classInstVars := self sbInstVarsOldParent: oldClass class newParent: newClass class oldChild: oldSubclass class.

		definition := oldSubclass definition.
		0 < (i := definition findString: 'instVarNames:' startingAt: 1) ifTrue: [
			j := definition indexOf: Character lf startingAt: i.
			string := String withAll: 'instVarNames: #('.
			instVars do: [:each | string addAll: each; add: Character space].
			string add: $).
			definition := (definition copyFrom: 1 to: i - 1) , string , (definition copyFrom: j to: definition size).
		].
		0 < (i := definition findString: 'classInstVars:' startingAt: 1) ifTrue: [
			j := definition indexOf: Character lf startingAt: i.
			string := String withAll: 'classInstVars: #('.
			classInstVars do: [:each | string addAll: each; add: Character space].
			string add: $).
			definition := (definition copyFrom: 1 to: i - 1) , string , (definition copyFrom: j to: definition size).
		].
		newSubclass := definition evaluate.
		aBoolean ifTrue: [self sbCopyMethodsFor: newSubclass].
		self classOrganizer update.
	].
!

sbRemoveClasses

	| isPackages containers classNames |
	isPackages := self _nextLine = 'packageList'.
	containers := self _nextLineAsList.
	classNames := (self _nextLineAsList reject: [:each | each isEmpty]) collect: [:each | (each subStrings: Character space) first asSymbol].
	self symbolList do: [:eachDictionary | 
		| dictionaryName |
		dictionaryName := eachDictionary name asString.
		classNames do: [:eachName |
			| class flag |
			(class := eachDictionary at: eachName ifAbsent: [nil]) notNil ifTrue: [
				selections removeAllKeys: selections keys.
				isPackages ifTrue: [
					flag := false. 
					containers do: [:each |
						flag := flag or: [(class category copyFrom: 1 to: (class category size min: each size)) = each].
						flag ifTrue: [
							selections at: #'package' put: each.
						].
					].
				] ifFalse: [
					flag := containers includes: dictionaryName.
					flag ifTrue: [
						selections at: #'dictionary' put: dictionaryName.
					].
				].
				flag ifTrue: [
					selectedClass := (eachDictionary at: eachName) superclass.
					selections 
						at: #'category' 		put: selectedClass category;
						at: #'className'	put: selectedClass name;
						at: #'class'				put: selectedClass;
						yourself.
					self sbRemoveKey: eachName fromDictionary: eachDictionary.
				].
			].
		].
	].
	self systemBrowserUpdate.
!

sbRemoveDictionaries: anOrderedCollection

	anOrderedCollection do: [:each | 
		self symbolList removeDictionaryNamed: each asSymbol.
	].
	self _refreshSymbolList.
	self systemBrowserUpdate.
!

sbRemoveGlobals

	| symbolList dictionaries globals |
	symbolList := self symbolList.
	dictionaries := self _nextLineAsList collect: [:each | each asSymbol].
	dictionaries := dictionaries collect: [:eachName | symbolList detect: [:eachDict | eachDict name = eachName]].
	globals := self _nextLineAsList collect: [:each | each asSymbol].
	dictionaries do: [:eachDict | 
		globals do: [:eachKey | 
			eachDict removeKey: eachKey ifAbsent: [].
		].
	].
	self systemBrowserUpdate.
!

sbRemoveHistory: aClass

	(ClassOrganizer new allSubclassesOf: aClass) asArray , (Array with: aClass) do: [:eachNewClass | 
		(self historyOf: eachNewClass) asArray do: [:eachClass | 
			eachClass ~~ eachNewClass ifTrue: [
				(self historyOf: eachNewClass) removeVersion: eachClass.
			].
		].
	].
!

sbRemoveKey: aSymbol fromDictionary: aDictionary

	aDictionary removeKey: aSymbol.
!

sbRemoveMethodCategories: anOrderedCollection

	| behavior |
	behavior := self sbClassFrom: anOrderedCollection.
	anOrderedCollection do: [:each | behavior removeCategory: each].
	self systemBrowserUpdate.
!

sbRemoveMethods: anOrderedCollection

	| behavior |
	behavior := self sbClassFrom: anOrderedCollection.
	anOrderedCollection do: [:each | behavior removeSelector: each asSymbol].
	self systemBrowserUpdate.
!

sbRemovePriorVersions

	| isPackages containers classNames |
	isPackages := self _nextLine = 'packageList'.
	containers := self _nextLineAsList.
	classNames := (self _nextLineAsList reject: [:each | each isEmpty]) collect: [:each | (each subStrings: Character space) first asSymbol].
	self symbolList do: [:eachDictionary | 
		| dictionaryName |
		dictionaryName := eachDictionary name asString.
		classNames do: [:eachName |
			| class flag |
			(class := eachDictionary at: eachName ifAbsent: [nil]) notNil ifTrue: [
				isPackages ifTrue: [
					flag := false.
					containers do: [:each | flag := flag or: [(class category copyFrom: 1 to: (class category size min: each size)) = each]].
				] ifFalse: [
					flag := containers includes: dictionaryName.
				].
				flag ifTrue: [
					| classHistory |
					classHistory := self historyOf: class.
					classHistory size - 1 timesRepeat: [
						classHistory removeVersion: classHistory first.
					].
				].
			].
		].
	].
	self systemBrowserUpdate.
!

sbRemoveRepository: list

	| description repository packages |
	description := list removeFirst.
	repository := self mcRepositoryGroup repositories detect: [:each | each description = description].
	packages := self mcWorkingCopyClass allManagers select: [:each | list includes: each package name].
	packages do: [:each | each repositoryGroup removeRepository: repository].
	self systemBrowserUpdate.
!

sbRevertClass

	| isPackages container className |
	isPackages := self _nextLine = 'packageList'.
	container := self _nextLine trimSeparators.
	className := self _nextLine trimSeparators.
	self symbolList do: [:eachDictionary | 
		| dictionaryName class flag |
		dictionaryName := eachDictionary name asString.
		(class := eachDictionary at: className ifAbsent: [nil]) notNil ifTrue: [
			isPackages ifTrue: [
				flag := (class category copyFrom: 1 to: (class category size min: container size)) = container.
			] ifFalse: [
				flag := container = dictionaryName.
			].
			flag ifTrue: [
				| history |
				history := class classHistory.
				(class == history last and: [1 < history size]) ifFalse: [self error: 'Unexpected class history!!'].
				history removeVersion: class.
				class := history last.
				eachDictionary at: class name put: class.
			].
		].
	].
	self systemBrowserUpdate.
!

sbRunClassTests: aString

	| behavior |
	behavior := self sbClassFrom: (aString subStrings: Character tab).
	^self _defectiveTestsIn: behavior.
!

sbRunMethodTests: aString

	| list class |
	list := aString subStrings: Character tab.
	class := (self sbClassFrom: list) thisClass.
	list do: [:each | class debug: each asSymbol].
	^true.
!

sbSavePackage: list

	| packageName package repositoryDescription repository versionName httpUser httpPassword comment |
	packageName := list removeFirst.
	package := self mcWorkingCopyClass allManagers detect: [:each | each package name = packageName].
	repositoryDescription := list removeFirst.
	repository := self mcRepositoryGroup repositories detect: [:each | each description = repositoryDescription].
	versionName := list removeFirst.
	list notEmpty ifTrue: [httpUser := list removeFirst].
	list notEmpty ifTrue: [httpPassword := list removeFirst].
	comment := self sbNextParagraph.
	[
		comment notEmpty and: [comment last asciiValue <= 32].
	] whileTrue: [
		comment := comment copyFrom: 1 to: comment size - 1.
	].
	(repository class name = #'MCHttpRepository') ifTrue: [
		repository
			user: httpUser;
			password: httpPassword;
			yourself.
	].
	self 
		mcStore: package 
		name: versionName 
		message: comment 
		repository: repository.
	self systemBrowserUpdate.
!

sbSetHomeDictionary: list

	| name dictionary packagePolicy |
	name := list removeFirst asSymbol.
	dictionary := self symbolList detect: [:each | each name = name].
	(packagePolicy := self _gsPackagePolicy) notNil ifTrue: [
		packagePolicy homeSymbolDict: dictionary.
	].
	self systemBrowserUpdate.
!

sbUniqueVersionName: aList

	| packageName package |
	packageName := aList removeFirst.
	package := self mcWorkingCopyClass allManagers detect: [:each | each package name = packageName].
	writeStream
		nextPutAll: 'uniqueVersionName'; lf;
		nextPutAll: package uniqueVersionName;
		yourself.

!

sbUnloadPackage: anOrderedCollection

	| string |
	string := anOrderedCollection removeFirst.
	(self mcWorkingCopyClass forPackage: (self _mcPackageClass named: string)) unload.
	self systemBrowserUpdate.
!

sbUpdateClassCategories

	| categories selection override |
	categories := Set new.
	classList do: [:each | categories add: each category].
	categories asSortedCollection do: [:each | 
		writeStream nextPutAll: each; tab.
	].
	writeStream lf.
	selection := self _nextLine.
	(override := selections at: #'category' ifAbsent: [nil]) notNil ifTrue: [selection := override , '-'].
	selection := 1 < selection size 
		ifTrue: [selection copyFrom: 1 to: selection size - 1]
		ifFalse: [''].
	selection notEmpty ifTrue: [
		categories := categories select: [:each | (each copyFrom: 1 to: (each size min: selection size)) = selection].
		categories isEmpty ifTrue: [selection := ''].
		categories notEmpty ifTrue: [
			classList := classList select: [:each | categories includes: each category].
		].
	].
	writeStream nextPutAll: selection; lf.
!

sbUpdateClasses

	| tabName |
	tabName := self _nextLine.
	writeStream nextPutAll: tabName; lf.
	tabName = 'classList' ifTrue: [^self sbUpdateClassList].
	tabName = 'classHierarchy' ifTrue: [^self sbUpdateClassHierarchy].
	self error: 'Unexpected token!!'.
!

sbUpdateClassHierarchy

	| currentSelection currentClass allClasses override testCaseClass |
	allClasses := IdentitySet new.
	"Add each class in dictionary/package to stream on a line with the superclass chain"
	classList do: [:each | 
		currentClass := each.
		[
			currentClass notNil.
		] whileTrue: [
			self sbAddNameOf: currentClass.
			allClasses add: currentClass.
			currentClass := currentClass superclass.
		].
		writeStream lf.
	].
	writeStream nextPut: $%; lf.
	"now figure out which class to select"
	currentSelection := self _nextLineAsList.
	(override := selections at: #'className' ifAbsent: [nil]) notNil ifTrue: [currentSelection := Array with: override].
	currentSelection isEmpty ifTrue: [
		selectedClass := nil.
	] ifFalse: [
		(currentClass := selections at: #'class' ifAbsent: [nil]) isNil ifTrue: [
			| className |
			className := (currentSelection last subStrings: Character space) first asSymbol.
			selectedClass := allClasses detect: [:each | each name = className] ifNone: [nil].
		] ifFalse: [
			selectedClass := nil.
			[
				selectedClass isNil and: [currentClass notNil].
			] whileTrue: [
				selectedClass := allClasses detect: [:each | each == currentClass] ifNone: [nil].
				currentClass := currentClass superclass.
			].
		].
	].
	currentClass := selectedClass.
	[
		currentClass notNil.
	] whileTrue: [
		self sbAddNameOf: currentClass.
		currentClass := currentClass superclass.
	].
	writeStream lf;
		nextPutAll: (selectedClass notNil and: [(testCaseClass := self objectInBaseNamed: #'TestCase') notNil and: [selectedClass inheritsFrom: testCaseClass]]) printString; tab;
		lf.
!

sbUpdateClassInfo

	| definition classComment |
	selectedClass isNil ifTrue: [^self sbClassTemplate].
	writeStream 
		nextPutAll: (self oopOf: selectedClass) printString; lf;
		nextPut: $(; lf;
		nextPutAll: (definition := selectedClass definition);
		nextPutAll: ')';
		nextPutAll: ((definition includesString: 'category: ''')
			ifTrue: ['']
			ifFalse: [' category: ' , selectedClass category printString]); lf;
		nextPut: $%; lf;
		yourself.
	(selectedClass class canUnderstand: #'comment') ifTrue: [
		classComment := selectedClass comment.
	] ifFalse: [
	(selectedClass class canUnderstand: #'classComment') ifTrue: [
		classComment := selectedClass classComment.
	] ifFalse: [
		(selectedClass class canUnderstand: #'description') ifTrue: [
			| description |
			description := selectedClass description.
			description class name = #'GsClassDocumentation' ifTrue: [
				classComment := description detailsAboutClass.
			].
		].
	]].
	classComment isNil ifTrue: [classComment := ''].
	writeStream 
		nextPutAll: classComment; lf;
		nextPut: $%; lf;
		yourself.
!

sbUpdateClassList

	| mySelections override testCaseClass |
	(classList asSortedCollection: [:a :b | a name <= b name]) do: [:eachClass | 
		self sbAddNameOf: eachClass.
	].
	writeStream lf.
	mySelections := self _nextLineAsList collect: [:each | (each subStrings: Character space) first asSymbol].
	(override := selections at: #'className' ifAbsent: [nil]) notNil ifTrue: [mySelections := Array with: override].
	mySelections := classList select: [:eachClass | mySelections includes: eachClass name].
	mySelections do: [:each | self sbAddNameOf: each].
	writeStream lf.
	(testCaseClass := self objectInBaseNamed: #'TestCase') isNil ifTrue: [
		false printOn: writeStream.
	] ifFalse: [
		(mySelections allSatisfy: [:each | each  inheritsFrom: testCaseClass]) printOn: writeStream.
	].
	writeStream lf.
	selectedClass := mySelections size = 1
		ifTrue: [mySelections first]
		ifFalse: [nil].
!

sbUpdateDictionaries

	| override packagePolicy home symbolList oldSelections newSelections fullList globals |
	oldSelections := self _nextLineAsList.
	(override := selections at: #'dictionary' ifAbsent: [nil]) notNil ifTrue: [oldSelections := Array with: override].
	symbolList := self symbolList.
	(packagePolicy := self _gsPackagePolicy) notNil  ifTrue: [
		home := packagePolicy homeSymbolDict.
	].
	fullList := symbolList collect: [:each | (each == home ifTrue: ['H'] ifFalse: ['V']) , each name].
	self writeList: fullList.
	fullList := fullList collect: [:each | each copyFrom: 2 to: each size].
	newSelections := oldSelections select: [:each | fullList includes: each].
	globals := Dictionary new.
	newSelections do: [:eachName | 
		| symbolDictionary globalKeyPrefix |
		globalKeyPrefix := 1 < newSelections size ifTrue: [eachName , '.'] ifFalse: [''].
		writeStream nextPutAll: eachName; tab.
		symbolDictionary := symbolList at: (fullList indexOf: eachName).
		symbolDictionary keys asSortedCollection do: [:eachKey |
			| eachGlobal |
			eachGlobal := symbolDictionary at: eachKey.
			(eachGlobal isBehavior and: [eachGlobal name == eachKey])
				ifTrue: [classList add: eachGlobal]
				ifFalse: [globals at: globalKeyPrefix , eachKey put: (symbolDictionary associationAt: eachKey)].
		].
	].
	writeStream lf.
	globals keys asSortedCollection do: [:eachKey | 
		| eachAssociation eachValue string |
		eachAssociation := globals at: eachKey.
		eachValue := eachAssociation value.
		string := self _asString: eachValue.
		100 < string size ifTrue: [string := string copyFrom: 1 to: 100].
		string := string collect: [:char | (char asciiValue < 32 or: [127 < char asciiValue]) ifTrue: [$.] ifFalse: [char]].
		string := String withAll: string asArray.
		writeStream 
"1"		nextPutAll: eachKey; tab; 
"2"		nextPutAll: eachValue _class name; tab; 
"3"		nextPutAll: string; tab; 
"4"		nextPutAll: (self oopOf: eachValue) printString; tab; 
"5"		nextPutAll: (self oopOf: eachAssociation) printString; lf.
	].
	writeStream nextPut: $%; lf.
!

sbUpdateMethod: aSymbol

	| classes method names selection |

	"Inherited implimentors"
	classes := self sbUpdateMethodInheritedImplementationsOf: aSymbol.
	names := classes collect: [:each | each name asString].
	self writeList: names.	"Line 1"

	"Which inherited implementation is selected?"
	selection := self _nextLine.
	(names includes: selection) ifFalse: [selection := names last].
	writeStream nextPutAll: selection; lf.	"Line 2"

	method := self compiledMethodAt: aSymbol inClass: (classes detect: [:each | each name asString = selection]).
	self _describeMethod: method.!

sbUpdateMethodBreakPointsFor: aMethod
	"Private - Answers an Array of step points"

	^aMethod _stepPointsFromBreakIpOffsets: aMethod _breakpointIpOffsets.		"at least as far back as 32-bit 6.3.0 and 64-bit 2.3.0, but not in 64-bit 3.0"
!

sbUpdateMethodCategories

	methodFilters := IdentitySet new.
	self _addMethodCategoryNamesToMethodFilters.
	methodFilters isEmpty ifTrue: [methodFilters := #(#'other')].
	"Reverse order to be consistent with variables, where we add superclasses to the end"
	self writeList: methodFilters asSortedCollection asArray reverse.
	self sbUpdateMethodFilterSelections.
!

sbUpdateMethodFilter

	self sbReadMethodFilter.
	selectedClass isNil ifTrue: [^self].
	methodFilterType = 'categoryList' ifTrue: [^self sbUpdateMethodCategories].
	methodFilterType = 'variableList' ifTrue: [^self sbUpdateMethodVariables].
	methodFilterType = 'pragmaList' ifTrue: [^self sbUpdateMethodPragmas].
	self error: 'Unexpected token!!'.
!

sbUpdateMethodFilterSelections

	| mySelections override |
	mySelections := self _nextLineAsList.
	(override := selections at: #'methodCategory' ifAbsent: [nil]) notNil ifTrue: [mySelections := Array with: override].
	mySelections := methodFilters select: [:each | mySelections includes: each asString].
	mySelections notEmpty ifTrue: [methodFilters := mySelections].
	self writeList: mySelections.
!

sbUpdateMethodInheritedImplementationsOf: aSymbol

	| classes currentClass |
	classes := OrderedCollection new.
	currentClass := classList last.
	[
		currentClass notNil.
	] whileTrue: [
		(self class: currentClass includesSelector: aSymbol) ifTrue: [classes add: currentClass].
		currentClass := currentClass superclass.
	].
	^classes reverse.
!

sbUpdateMethodPragmas

	methodFilters := #().
	self sbUpdateMethodFilterSelections.
!

sbUpdateMethods

	| selectors isTestClass gsPackagePolicy anySatisfy |
	selectedClass isNil ifTrue: [^self].
	anySatisfy := false.
	selectedClass _allSuperList do: [:each | 
		anySatisfy := anySatisfy or: [each name = #'TestCase'].
	].
	isTestClass := anySatisfy ifTrue: [$T] ifFalse: [$F].
	gsPackagePolicy := self _gsPackagePolicy.
	methodFilterType = 'categoryList' ifTrue: [selectors := self sbUpdateMethodsByCategories] ifFalse: [
	methodFilterType = 'variableList' ifTrue: [selectors := self sbUpdateMethodsByVariables] ifFalse: [
	methodFilterType = 'pragmaList' ifTrue: [selectors := self sbUpdateMethodsByPragmas] ifFalse: [
		self error: 'Unrecognized methodFilterType: ' , methodFilterType printString]]].
	selectors := selectors asSortedCollection.
	selectors do: [:each | 	"JadeSystemBrowserPresenter>>#'updateMethodList' "
		writeStream 
"1"			nextPutAll: each; tab;
"2"			nextPut: ((self _selectedClassOverridesSelector: each) ifTrue: [$T] ifFalse: [$F]); tab;
"3"			nextPut: isTestClass; tab;
"4"			nextPut: ((self _packagePolicy: gsPackagePolicy includesSelector: each forClass: selectedClass) ifTrue: [$T] ifFalse: [$F]); tab;
"5"			nextPutAll: (self _methodSignatureForSelector: each); tab;	"sometimes the method key is different from the selector and from the method signature (particularly in Ruby)"
			lf.
	].
	writeStream nextPut: $%; lf.
	self sbUpdateMethodSelectionsIn: selectors.
!

sbUpdateMethodsByCategories

	| selectors |
	selectors := IdentitySet new.
	classList do: [:eachClass |
		eachClass selectors do: [:eachSelector |
			(methodFilters includes: (self _behavior: eachClass categoryOfSelector: eachSelector)) ifTrue: [selectors add: eachSelector].
		].
	].
	^selectors.
!

sbUpdateMethodsByPragmas
	"Private - none before 3.x"

	^#()!

sbUpdateMethodsByVariables

	| selectors filters |
	selectors := IdentitySet new.
	filters := IdentitySet withAll: (methodFilters select: [:each | each isSymbol]).
	selectedClass selectors do: [:eachSelector | 
		| gsMethod |
		gsMethod := self compiledMethodAt: eachSelector inClass: selectedClass.
		(gsMethod instVarsAccessed * filters) notEmpty ifTrue: [selectors add: eachSelector].
	].
	^selectors.
!

sbUpdateMethodSelectionsIn: aList

	| priorSelections override newSelections |
	priorSelections := self _nextLineAsList.
	(override := selections at: #'method' ifAbsent: [nil]) notNil ifTrue: [priorSelections := Array with: override].
	newSelections := aList select: [:each | priorSelections includes: each asString].
	self writeList: newSelections.
	newSelections size = 1 ifTrue: [self sbUpdateMethod: newSelections first].
!

sbUpdateMethodStepPointsFor: aMethod
	"Private - Answers an Array of Associations (offset -> selector) indexed by step point"

	| offsets selectors |
	offsets := (self homeMethodFor: aMethod)  _sourceOffsets.
	selectors := Array new.
	1 to: offsets size do: [:i | 		"exists as far back as 32-bit 6.3.0"
		| offset ip association |
		offset := offsets at: i.
		ip := (aMethod _ipForStepPoint: i) + 2.		"dropped in 64-bit 3.0"
		association := offset -> ''.
		ip <= aMethod size ifTrue: [
			| literal |
			((literal := aMethod at: ip) isKindOf: Symbol) ifTrue: [
				association value: literal.
			].
		].
		selectors add: association.
	].
	^selectors.
!

sbUpdateMethodVariables

	| currentClass |
	currentClass := classList notEmpty ifTrue: [classList last] ifFalse: [nil].
	methodFilters := OrderedCollection new.
	[
		currentClass notNil.
	] whileTrue: [
		methodFilters
			addAll: currentClass instVarNames reverse;
			add: ' ' , currentClass name;
			yourself.
		currentClass := currentClass superclass.
	].
	self writeList: methodFilters.
	self sbUpdateMethodFilterSelections.
!

sbUpdatePackage: aString

	| package workingCopy list index |
	package := self _mcPackageClass named: aString.
	workingCopy := self mcWorkingCopyClass forPackage: package.
	list := workingCopy ancestors collect: [:each | 0 -> each].
	index := 1.
	[
		list size < 4 and: [index <= list size].
	] whileTrue: [
		| assoc |
		assoc := list at: index.
		assoc value ancestors do: [:parent | list add: assoc key + 1 -> parent].
		index := index + 1.
	].
	list do: [:each | 
		| date time |
		date := each value date isNil 
			ifTrue: ['']
			ifFalse: [each value date asStringUsingFormat: #(3 2 1 $- 1 1)].
		time := each value time isNil
			ifTrue: ['']
			ifFalse: [each value time asStringUsingFormat: #($: true false)].
		writeStream 
			nextPutAll: each key printString; tab;
			nextPutAll: each value name; tab;
			nextPutAll: date; 
			nextPut: $T;
			nextPutAll: time; tab;
			nextPutAll: (each value message collect: [:char |(char asciiValue < 32 or: [127 < char asciiValue]) ifTrue: [$.] ifFalse: [char]]);
			lf.
	].
	writeStream nextPut: $%; lf.
	workingCopy repositoryGroup repositories do: [:each | 
		writeStream 
			nextPutAll: each class name; tab;
			nextPutAll: each description; tab;
			yourself.
		(each class name = #'MCHttpRepository') ifTrue: [
			writeStream
				nextPutAll: each user; tab;
				nextPutAll: each password;
				yourself.
		] ifFalse: [
			writeStream tab; tab.
		].
		writeStream lf.
	].
	writeStream nextPut: $%; lf.!

sbUpdatePackages

	| override modifiedList oldSelections newSelections fullList |
	oldSelections := self _nextLineAsList.
	(override := selections at: #'package' ifAbsent: [nil]) notNil ifTrue: [oldSelections := Array with: override].
	fullList := self _mcLoadedVersionNames subStrings: Character lf.
	fullList := fullList reject: [:each | each isEmpty].
	fullList := fullList asSortedCollection asArray.
	fullList := fullList collect: [:each | each subStrings: Character tab].
	fullList := fullList reject: [:each | each isEmpty].
	modifiedList := (fullList select: [:each | (each at: 2) = 'Y']) collect: [:each | each at: 3].
	fullList := fullList collect: [:each | each at: 3].
	self 
		writeList: fullList;
		writeList: modifiedList;
		yourself.
	newSelections := oldSelections select: [:each | fullList includes: each].
	(newSelections isEmpty and: [oldSelections size = 1]) ifTrue: [
			newSelections := fullList select: [:each | (oldSelections first copyFrom: 1 to: (oldSelections first size min: each size)) = each].
	].
	newSelections do: [:each | 
		writeStream nextPutAll: each; tab.
		classList addAll: (self _mcPackageClass named: each) packageInfo classes.
	].
	writeStream lf.
	newSelections size = 1 ifTrue: [self sbUpdatePackage: newSelections first].
!

sbUpdatePackagesOrDictionaries

	| selectedTab |
	selectedTab := self _nextLine.
	(self mcWorkingCopyClass isNil or: [self _gsPackagePolicy isNil]) ifTrue: [selectedTab := 'dictionaryList'].
	writeStream nextPutAll: selectedTab; lf.
	classList := OrderedCollection new.
	selectedTab = 'dictionaryList' ifTrue: [^self sbUpdateDictionaries].
	selectedTab = 'packageList' ifTrue: [^self sbUpdatePackages].
	self error: 'unexpected token'.
!

sbUpdateSuperclass

	| class tabName selected index |
	tabName := self _nextLine.
	(#('default' 'instanceTab' 'classTab') includes: tabName) ifFalse: [self error: 'Unexpected token!!'].
	tabName = 'default' ifTrue: [
		tabName := (selectedClass notNil and: [selectedClass selectors isEmpty and: [selectedClass class selectors notEmpty]]) 
			ifTrue: ['classTab']
			ifFalse: ['instanceTab'].
	].
	writeStream nextPutAll: tabName; lf.
	selectedClass notNil ifTrue: [
		selectedClass := tabName = 'instanceTab'
			ifTrue: [selectedClass]
			ifFalse: [selectedClass class].
	].
	class := selectedClass.
	classList := OrderedCollection new.
	[
		class notNil.
	] whileTrue: [
		classList add: class.
		self sbAddNameOf: class.
		class := self _environmentSuperClassFor: class.
	].
	classList := classList reverse.
	selected := self _nextLine.
	index := classList findFirst: [:each | each name asString = selected].
	index = 0 ifTrue: [index := classList size].
	0 < index ifTrue: [classList := classList copyFrom: index to: classList size].
	writeStream lf.
	classList notEmpty ifTrue: [
		selectedClass := classList first.
		self sbAddNameOf: selectedClass.
	].
	writeStream lf.
!

symbolList

	^System myUserProfile symbolList.
!

systemBrowser: aString

	^self copy systemBrowserA: aString.
!

systemBrowserA: aString

	| time |
	time := self _millisecondsElapsedTime: [
		selections := Dictionary new.
		readStream := ReadStream on: (self _decodeString: aString).
		writeStream := self _writeStreamOnString.
		writeStream lf.
		self environment: (readStream upTo: Character space) asNumber.
		self _systemBrowserCommand.
	].
	^self _encodeString: time printString , writeStream contents.
!

systemBrowserUpdate

	writeStream nextPutAll: 'update'; lf.
	self 
		sbUpdatePackagesOrDictionaries;
		sbUpdateClassCategories;
		sbUpdateClasses;
		sbUpdateClassInfo;
		sbUpdateSuperclass;
		sbUpdateMethodFilter;
		sbUpdateMethods;
		yourself.
!

writeList: aList

	aList do: [:each | writeStream nextPutAll: each; tab].
	writeStream lf.
! !
!JadeServer categoriesFor: #_addMethodCategoryNamesToMethodFilters!private!System Browser! !
!JadeServer categoriesFor: #_isPackagePolicyEnabled!private!System Browser! !
!JadeServer categoriesFor: #_objectSecurityPolicyFor:!private!System Browser! !
!JadeServer categoriesFor: #_packagePolicy:includesSelector:forClass:!private!System Browser! !
!JadeServer categoriesFor: #_selectedClassOverridesSelector:!private!System Browser! !
!JadeServer categoriesFor: #_systemBrowserCommand!private!System Browser! !
!JadeServer categoriesFor: #class:includesSelector:!Classes!public! !
!JadeServer categoriesFor: #compiledMethodAt:inClass:!private!System Browser! !
!JadeServer categoriesFor: #dictionaryAndSymbolOf:!private!System Browser! !
!JadeServer categoriesFor: #dictionaryAndSymbolOf:forUser:!private!System Browser! !
!JadeServer categoriesFor: #environment!private!System Browser! !
!JadeServer categoriesFor: #environment:!private!System Browser! !
!JadeServer categoriesFor: #historyOf:!private! !
!JadeServer categoriesFor: #sbAddDictionary:!private! !
!JadeServer categoriesFor: #sbAddMethodCategory:!private!System Browser! !
!JadeServer categoriesFor: #sbAddMissingAccessors:!private!System Browser! !
!JadeServer categoriesFor: #sbAddNameOf:!private!System Browser! !
!JadeServer categoriesFor: #sbAddPackage:!private!System Browser! !
!JadeServer categoriesFor: #sbAddRepository:!private!System Browser! !
!JadeServer categoriesFor: #sbBreak:!private!System Browser! !
!JadeServer categoriesFor: #sbBrowseClassReferences:!private!System Browser! !
!JadeServer categoriesFor: #sbBrowseGlobalReferences:!private!System Browser! !
!JadeServer categoriesFor: #sbBrowseImplementors:!private!System Browser! !
!JadeServer categoriesFor: #sbBrowseMethodHistory:!private!System Browser! !
!JadeServer categoriesFor: #sbBrowseMethodsContaining:!private!System Browser! !
!JadeServer categoriesFor: #sbBrowseMethodsWithPragma:!private!System Browser! !
!JadeServer categoriesFor: #sbBrowseSenders:!private!System Browser! !
!JadeServer categoriesFor: #sbChangeClassName:!private!System Browser! !
!JadeServer categoriesFor: #sbChangesInPackage:!private!System Browser! !
!JadeServer categoriesFor: #sbCheckUniqueClassName:!private!System Browser! !
!JadeServer categoriesFor: #sbClass:!private!System Browser! !
!JadeServer categoriesFor: #sbClassCategory:!private!System Browser! !
!JadeServer categoriesFor: #sbClassComment:!private!System Browser! !
!JadeServer categoriesFor: #sbClassesToDictionary:!private!System Browser! !
!JadeServer categoriesFor: #sbClassFrom:!private!System Browser! !
!JadeServer categoriesFor: #sbClassTemplate!private!System Browser! !
!JadeServer categoriesFor: #sbComparePackages:!private!System Browser! !
!JadeServer categoriesFor: #sbCopyMethodsFor:!private!System Browser! !
!JadeServer categoriesFor: #sbFileOutClass:!private!System Browser! !
!JadeServer categoriesFor: #sbFileOutDictionary:!private!System Browser! !
!JadeServer categoriesFor: #sbFileOutMethod:!private!System Browser! !
!JadeServer categoriesFor: #sbFindClass!private!System Browser! !
!JadeServer categoriesFor: #sbFindClassPackageMap!private!System Browser! !
!JadeServer categoriesFor: #sbFindSelectors:!private!System Browser! !
!JadeServer categoriesFor: #sbInstVarsOldParent:newParent:oldChild:!private!System Browser! !
!JadeServer categoriesFor: #sbListMethodPragmas!private!System Browser! !
!JadeServer categoriesFor: #sbLoadLatestVersionOfConfiguration:!private!System Browser! !
!JadeServer categoriesFor: #sbMethodCategory:!private!System Browser! !
!JadeServer categoriesFor: #sbMethodClass:!private!System Browser! !
!JadeServer categoriesFor: #sbMigrateAll:!private!System Browser! !
!JadeServer categoriesFor: #sbNextParagraph!private!System Browser! !
!JadeServer categoriesFor: #sbPostSaveClass:!private!System Browser! !
!JadeServer categoriesFor: #sbReadMethodFilter!private!System Browser! !
!JadeServer categoriesFor: #sbRecompileSubclassesOf:andCopyMethods:!private!System Browser! !
!JadeServer categoriesFor: #sbRemoveClasses!private!System Browser! !
!JadeServer categoriesFor: #sbRemoveDictionaries:!private!System Browser! !
!JadeServer categoriesFor: #sbRemoveGlobals!private!System Browser! !
!JadeServer categoriesFor: #sbRemoveHistory:!private!System Browser! !
!JadeServer categoriesFor: #sbRemoveKey:fromDictionary:!private!System Browser! !
!JadeServer categoriesFor: #sbRemoveMethodCategories:!private!System Browser! !
!JadeServer categoriesFor: #sbRemoveMethods:!private!System Browser! !
!JadeServer categoriesFor: #sbRemovePriorVersions!private!System Browser! !
!JadeServer categoriesFor: #sbRemoveRepository:!private!System Browser! !
!JadeServer categoriesFor: #sbRevertClass!private!System Browser! !
!JadeServer categoriesFor: #sbRunClassTests:!private!System Browser! !
!JadeServer categoriesFor: #sbRunMethodTests:!private!System Browser! !
!JadeServer categoriesFor: #sbSavePackage:!private!System Browser! !
!JadeServer categoriesFor: #sbSetHomeDictionary:!private!System Browser! !
!JadeServer categoriesFor: #sbUniqueVersionName:!private!System Browser! !
!JadeServer categoriesFor: #sbUnloadPackage:!private!System Browser! !
!JadeServer categoriesFor: #sbUpdateClassCategories!private!System Browser! !
!JadeServer categoriesFor: #sbUpdateClasses!private!System Browser! !
!JadeServer categoriesFor: #sbUpdateClassHierarchy!private!System Browser! !
!JadeServer categoriesFor: #sbUpdateClassInfo!private!System Browser! !
!JadeServer categoriesFor: #sbUpdateClassList!private!System Browser! !
!JadeServer categoriesFor: #sbUpdateDictionaries!private!System Browser! !
!JadeServer categoriesFor: #sbUpdateMethod:!private!System Browser! !
!JadeServer categoriesFor: #sbUpdateMethodBreakPointsFor:!private!System Browser! !
!JadeServer categoriesFor: #sbUpdateMethodCategories!private!System Browser! !
!JadeServer categoriesFor: #sbUpdateMethodFilter!private!System Browser! !
!JadeServer categoriesFor: #sbUpdateMethodFilterSelections!private!System Browser! !
!JadeServer categoriesFor: #sbUpdateMethodInheritedImplementationsOf:!private!System Browser! !
!JadeServer categoriesFor: #sbUpdateMethodPragmas!private!System Browser! !
!JadeServer categoriesFor: #sbUpdateMethods!private!System Browser! !
!JadeServer categoriesFor: #sbUpdateMethodsByCategories!private!System Browser! !
!JadeServer categoriesFor: #sbUpdateMethodsByPragmas!private!System Browser! !
!JadeServer categoriesFor: #sbUpdateMethodsByVariables!private!System Browser! !
!JadeServer categoriesFor: #sbUpdateMethodSelectionsIn:!private!System Browser! !
!JadeServer categoriesFor: #sbUpdateMethodStepPointsFor:!private!System Browser! !
!JadeServer categoriesFor: #sbUpdateMethodVariables!private!System Browser! !
!JadeServer categoriesFor: #sbUpdatePackage:!private!System Browser! !
!JadeServer categoriesFor: #sbUpdatePackages!private!System Browser! !
!JadeServer categoriesFor: #sbUpdatePackagesOrDictionaries!private!System Browser! !
!JadeServer categoriesFor: #sbUpdateSuperclass!private!System Browser! !
!JadeServer categoriesFor: #symbolList!private!System Browser! !
!JadeServer categoriesFor: #systemBrowser:!public!System Browser! !
!JadeServer categoriesFor: #systemBrowserA:!private!System Browser! !
!JadeServer categoriesFor: #systemBrowserUpdate!private!System Browser! !
!JadeServer categoriesFor: #writeList:!private!System Browser! !

!JadeServer32bit methodsFor!

systemBrowser: aString

	Exception
		category: nil 
		number: nil 
		do: [:ex :cat :num :args | 
			readStream := nil.
			ex resignal: cat number: num args: args.
			self error: 'Should not return!!'.
		].
	^super systemBrowser: aString.
! !
!JadeServer32bit categoriesFor: #systemBrowser:!public!System Browser! !

!JadeServer64bit methodsFor!

sbRemoveKey: aSymbol fromDictionary: aDictionary

	| aClass array |
	aClass := aDictionary at: aSymbol.
	array := self dictionaryAndSymbolOf: aClass.
	((array at: 1) == aDictionary and: [
		(array at: 2) == aSymbol and: [
		(Class canUnderstand: #'removeFromSystem') and: [	"mark package as modified"
		aClass removeFromSystem]]]) ifFalse: [
			aDictionary removeKey: aSymbol.
		].!

systemBrowser: aString

	[
		^super systemBrowser: aString.
	] on: Error do: [:ex |
		readStream := nil.
		ex pass.
	].
! !
!JadeServer64bit categoriesFor: #sbRemoveKey:fromDictionary:!private!System Browser! !
!JadeServer64bit categoriesFor: #systemBrowser:!public!System Browser! !

!JadeServer64bit32 methodsFor!

dictionaryAndSymbolOf: aClass

	| array |
	array := self symbolList dictionariesAndSymbolsOf: aClass.
	^array isEmpty
		ifTrue: [nil]
		ifFalse: [array first].
!

dictionaryAndSymbolOf: aClass forUser: aUserProfile

	| array |
	array := aUserProfile symbolList dictionariesAndSymbolsOf: aClass.
	^array isEmpty
		ifTrue: [nil]
		ifFalse: [array first].
! !
!JadeServer64bit32 categoriesFor: #dictionaryAndSymbolOf:!private! !
!JadeServer64bit32 categoriesFor: #dictionaryAndSymbolOf:forUser:!private! !

!JadeServer64bit34 methodsFor!

sbUpdateMethodsByCategories

	| selectors |
	selectors := IdentitySet new.
	classList do: [:eachClass |
		(eachClass selectorsForEnvironment: environment) do: [:eachSelector |
			| category |
			category := eachClass categoryOfSelector: eachSelector environmentId: environment.
			((category isNil and: [methodFilters includes: #'other']) or: [methodFilters includes: category]) ifTrue: [
				selectors add: eachSelector.
			].
		].
	].
	^selectors.
! !
!JadeServer64bit34 categoriesFor: #sbUpdateMethodsByCategories!private!System Browser! !

!JadeServer64bit3x methodsFor!

class: aClass includesSelector: aSelector

	^aClass includesSelector: (self _decodeString: aSelector) asSymbol environmentId: environment.
!

compiledMethodAt: aSymbol inClass: aClass

	| method |
	method := aClass compiledMethodAt: aSymbol environmentId: environment.
	method ifNil: [self error: 'Lookup failed for selector ' , aSymbol , ' inClass ' , aClass name , ' in environment ' , environment printString].
	^method.!

environment

	^environment!

environment: anInteger

	environment := anInteger.
!

initialize

	super initialize.
	environment := 0.
!

sbBrowseMethodsWithPragma: anOrderedCollection

	| methods symbol |
	symbol := anOrderedCollection removeFirst asSymbol.
	methods := IdentitySet new.
	self symbolList do: [:eachDict | 
		eachDict do: [:eachGlobal | 
			eachGlobal isBehavior ifTrue: [
				(Array with: eachGlobal class with: eachGlobal) do: [:eachBehavior | 
					(eachBehavior methodDictForEnv: environment) do: [:eachMethod | 
						(eachMethod pragmas anySatisfy: [:eachPragma | symbol == eachPragma keyword]) ifTrue: [methods add: eachMethod].
					].
				].
			].
		].
	].
	writeStream 
		nextPutAll: 'browseMethodsWithPragma'; lf;
		nextPutAll: (self _streamOfMethods: methods);
		yourself.
!

sbClassComment: anOrderedCollection

	(self sbClassFrom: anOrderedCollection) thisClass comment: self sbNextParagraph trimSeparators.
	self systemBrowserUpdate.
!

sbFileOutMethod: anOrderedCollection

	| aClass |
	aClass := self sbClassFrom: anOrderedCollection.
	writeStream nextPutAll: (aClass fileOutMethod: anOrderedCollection removeFirst asSymbol environmentId: environment).

!

sbListMethodPragmas: aList

	| pragmas |
	pragmas := IdentitySet new.
	self symbolList do: [:eachDict | 
		eachDict do: [:eachGlobal | 
			eachGlobal isBehavior ifTrue: [
				(Array with: eachGlobal with: eachGlobal class) do: [:eachBehavior | 
					(eachBehavior methodDictForEnv: environment) do: [:eachMethod | 
						pragmas addAll: (eachMethod pragmas collect: [:eachPragma | eachPragma keyword]).
					].
				].
			].
		].
	].
	pragmas asSortedCollection do: [:each | writeStream nextPutAll: each; tab].
	^pragmas!

sbMethod: anOrderedCollection

	| behavior category string gsMethod |
	behavior := self sbClassFrom: anOrderedCollection.
	category := anOrderedCollection notEmpty ifTrue: [anOrderedCollection removeFirst] ifFalse: ['other'].
	string := self sbNextParagraph.
	gsMethod := behavior
		compileMethod: string 
		dictionaries: self symbolList 
		category: category asSymbol 
		environmentId: environment.
	selections 
		at: #'methodCategory' 	put: (self _behavior: gsMethod inClass categoryOfSelector: gsMethod selector) asString;
		at: #'method'			put: gsMethod selector asString;
		yourself.
	self systemBrowserUpdate.
!

sbUpdateMethodBreakPointsFor: aMethod
	"Private - Answers an Array of step points"

	| list array |
	(array := aMethod _allBreakpoints) isNil ifTrue: [^#()].      "{ breakpointNumber1 . method . ipOffset1 . ... }"
	list := Array new.
	1 to: array size by: 3 do:[:k |
		list add: (aMethod
			_stepPointForMeth: (array at: k + 1)
			ip: (array at: k + 2)).
	].
	^list.
!

sbUpdateMethodPragmas

	| currentClass |
	currentClass := ((self objectInBaseNamed: #'Pragma') notNil and: [selectedClass notNil]) ifTrue: [selectedClass] ifFalse: [nil].
	methodFilters := IdentitySet new.
	currentClass notNil ifTrue: [
		(currentClass methodDictForEnv: environment) do: [:each | methodFilters addAll: each pragmas].
	].
	methodFilters := methodFilters collect: [:each | each keyword].
	methodFilters := methodFilters asSortedCollection: [:a :b | a > b].
	self writeList: methodFilters.
	self sbUpdateMethodFilterSelections.
!

sbUpdateMethodsByCategories

	| selectors |
	selectors := IdentitySet new.
	classList do: [:eachClass |
		(eachClass selectorsForEnvironment: environment) do: [:eachSelector |
			| category |
			category := eachClass categoryOfSelector: eachSelector environmentId: environment.
			((category isNil and: [methodFilters includes: #'other']) or: [methodFilters includes: category]) ifTrue: [
				| method |
				method := eachClass compiledMethodAt: eachSelector environmentId: environment.
				method isRubyBridgeMethod ifFalse: [
					selectors add: eachSelector.
				].
			].
		].
	].
	^selectors.
!

sbUpdateMethodsByPragmas

	| selectors |
	selectors := IdentitySet new.
	methodFilters isEmpty ifTrue: [^#()].
	(selectedClass selectorsForEnvironment: environment) do: [:eachSelector | 
		| gsMethod |
		gsMethod := selectedClass compiledMethodAt: eachSelector environmentId: environment.
		gsMethod pragmas do: [:eachPragma | 
			(methodFilters includes: eachPragma keyword) ifTrue: [selectors add: eachSelector].
		].
	].
	^selectors.
!

sbUpdateMethodsByVariables

	| selectors filters |
	selectors := IdentitySet new.
	filters := IdentitySet withAll: (methodFilters select: [:each | each isSymbol]).
	(selectedClass selectorsForEnvironment: environment) do: [:eachSelector | 
		| gsMethod |
		gsMethod := selectedClass compiledMethodAt: eachSelector environmentId: environment.
		(gsMethod instVarsAccessed * filters) notEmpty ifTrue: [selectors add: eachSelector].
	].
	^selectors.
!

sbUpdateMethodStepPointsFor: aMethod
	"Private - Answers an Array of Associations (offset -> selector) indexed by step point"

	|  selectors list |
	(selectors := aMethod _allDebugInfo: 10) ifNil: [^#()].
	list := (self homeMethodFor: aMethod)  _sourceOffsets.
	list := list collect: [:each | 		"exists as far back as 32-bit 6.3.0"
		| index selector |
		selector := ''.
		index := selectors indexOf: each.
		0 < index ifTrue: [selector := selectors at: index + 1].
		each -> selector.
	].
	^list.

! !
!JadeServer64bit3x categoriesFor: #class:includesSelector:!public!System Browser! !
!JadeServer64bit3x categoriesFor: #compiledMethodAt:inClass:!private!System Browser! !
!JadeServer64bit3x categoriesFor: #environment!public!System Browser! !
!JadeServer64bit3x categoriesFor: #environment:!public!System Browser! !
!JadeServer64bit3x categoriesFor: #initialize!private! !
!JadeServer64bit3x categoriesFor: #sbBrowseMethodsWithPragma:!private!System Browser! !
!JadeServer64bit3x categoriesFor: #sbClassComment:!private!System Browser! !
!JadeServer64bit3x categoriesFor: #sbFileOutMethod:!private!System Browser! !
!JadeServer64bit3x categoriesFor: #sbListMethodPragmas:!private!System Browser! !
!JadeServer64bit3x categoriesFor: #sbMethod:!private!System Browser! !
!JadeServer64bit3x categoriesFor: #sbUpdateMethodBreakPointsFor:!private!System Browser! !
!JadeServer64bit3x categoriesFor: #sbUpdateMethodPragmas!private!System Browser! !
!JadeServer64bit3x categoriesFor: #sbUpdateMethodsByCategories!private!System Browser! !
!JadeServer64bit3x categoriesFor: #sbUpdateMethodsByPragmas!private!System Browser! !
!JadeServer64bit3x categoriesFor: #sbUpdateMethodsByVariables!private!System Browser! !
!JadeServer64bit3x categoriesFor: #sbUpdateMethodStepPointsFor:!private!System Browser! !

!JadeTextDocument methodsFor!

jadeBrowseClasses

	gciSession hasServer ifTrue: [
		^JadeSystemBrowser showOnSession: gciSession.
	].
	MessageBox
		warning: 'Server initialization failed at login.'
		caption: 'Unable to Open Browser'.
! !
!JadeTextDocument categoriesFor: #jadeBrowseClasses!Jade!private! !

!JadeToolsToolBarPresenter methodsFor!

browseClasses

	JadeSystemBrowser showOnSession: gciSession.
! !
!JadeToolsToolBarPresenter categoriesFor: #browseClasses!public! !

"End of package definition"!

