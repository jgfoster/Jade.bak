| package |
package := Package name: 'Rowan UI Base'.
package paxVersion: 1;
	basicComment: 'Rowan GUI tools built on Jade Smalltalk for Dolphin. '.


package classNames
	add: #BrowserUpdate;
	add: #PackageMethodListPresenter;
	add: #Rowan;
	add: #RowanClassCategoryUpdate;
	add: #RowanClassesUpdate;
	add: #RowanClassHierarchyUpdate;
	add: #RowanClassInfoUpdate;
	add: #RowanClassService;
	add: #RowanDictionaryUpdate;
	add: #RowanGlobalsUpdate;
	add: #RowanKeyValuePrompter;
	add: #RowanLoginShell;
	add: #RowanMethodListBrowser;
	add: #RowanMethodListPresenter;
	add: #RowanMethodSelectionPresenter;
	add: #RowanMethodService;
	add: #RowanMethodSourcePresenter;
	add: #RowanMethodsUpdate;
	add: #RowanMethodUpdate;
	add: #RowanPackagePresenter;
	add: #RowanPackageService;
	add: #RowanPackageShell;
	add: #RowanPackageUpdate;
	add: #RowanPatchBrowser;
	add: #RowanPresenter;
	add: #RowanProjectListPresenter;
	add: #RowanProjectListShell;
	add: #RowanProjectsBrowserPresenter;
	add: #RowanProjectService;
	add: #RowanProjectsSystemBrowser;
	add: #RowanProjectsUpdate;
	add: #RowanSavePackageDialog;
	add: #RowanService;
	add: #RowanServiceTest;
	add: #RowanShell;
	add: #RowanSuperclassUpdate;
	add: #RowanSystemBrowser;
	add: #RowanSystemBrowserPresenter;
	add: #RowanTranscript;
	yourself.

package methodNames
	add: #CodeSourcePresenter -> #browseSelectedClass;
	add: #GciSession -> #hasServer;
	add: #GciSession -> #initializeServer;
	add: #GciSession -> #postLoginAs:useSocket:;
	add: #GciSession -> #titleBarFor:;
	add: #GciSession -> #verifyRowanLoaded;
	add: #GsMethod -> #methodDefinitionService;
	add: #JadeImageStripper -> #closeLoginShells;
	add: #JadeImageStripper -> #createVersionResource;
	add: #JadeImageStripper -> #requiredClasses;
	add: #JadeImageStripper -> #requiredPackageNames;
	add: #JadeLoginShell -> #aboutJadeite;
	add: #JadePresenterA -> #browseImplementorsOf:;
	add: #JadePresenterA -> #browseSendersOf:;
	add: #JadeServer -> #_describeMethod:;
	add: #JadeServer -> #sbAddPackage:;
	add: #JadeServer -> #sbChangesInPackage:;
	add: #JadeServer -> #sbClassTemplate;
	add: #JadeServer -> #sbRemoveClasses;
	add: #JadeServer -> #sbRemoveMethods:;
	add: #JadeServer -> #sbUnloadPackage:;
	add: #JadeServer -> #sbUpdateClassCategories;
	add: #JadeServer -> #sbUpdateClassHierarchy;
	add: #JadeServer -> #sbUpdateClassInfo;
	add: #JadeServer -> #sbUpdateClassList;
	add: #JadeServer -> #sbUpdateDictionaries;
	add: #JadeServer -> #sbUpdateMethodCategories;
	add: #JadeServer -> #sbUpdateMethods;
	add: #JadeServer -> #sbUpdateMethodVariables;
	add: #JadeServer -> #sbUpdatePackages;
	add: #JadeServer -> #sbUpdateSuperclass;
	add: #JadeServer64bit -> #recompile:withSource:;
	add: #JadeServer64bit -> #systemBrowserSTON:;
	add: #JadeServer64bit3x -> #compileMethod:behavior:symbolList:inCategory:;
	add: #JadeServer64bit3x -> #sbClassComment:;
	add: #JadeServer64bit3x -> #sbUpdateMethodPragmas;
	add: #JadeSystemBrowserPresenter -> #browseMethodsAndSelect:;
	add: #JadeSystemBrowserPresenter -> #browseMethodsAndSelect:type:;
	add: #JadeSystemBrowserPresenter -> #onViewOpened;
	add: #JadeSystemBrowserPresenter -> #packageTabName;
	add: #JadeSystemBrowserPresenter -> #queryCommand:;
	add: #JadeSystemBrowserPresenter -> #savePackage;
	add: #JadeSystemBrowserPresenter -> #updateMethod;
	add: #JadeSystemBrowserPresenter -> #updateSelector;
	add: #JadeTextDocument -> #aboutJadeite;
	add: #JadeTextDocument -> #jadeBrowseClasses;
	add: #JadeToolsToolBarPresenter -> #browseClasses;
	add: #JadeTranscript -> #methodsChanged24;
	add: #JadeTranscript -> #methodsChangedDays;
	add: #JadeTranscript -> #openRowanProjectList;
	add: #JadeTreeMethodListPresenter -> #browseMethodsFromString:;
	add: #JadeTreeMethodListPresenter -> #browseMethodsFromString:methodName:;
	add: #JadeTreeMethodListPresenter -> #browseMethodsFromString:methodName:type:;
	add: #JadeTreeMethodListPresenter -> #onDropMethodsTree:;
	add: #MCClassDefinition -> #initialize:;
	add: #MCPatchBrowser -> #browseChangedThing;
	add: #MCPatchBrowser -> #operationSelected;
	add: #MethodListPresenter -> #browseClass;
	add: #MethodListPresenter -> #browseMethodsContaining;
	add: #MethodSourcePresenter -> #fileSave;
	add: #Object -> #rowanFixMe;
	add: #Presenter -> #updateReady:;
	add: #Presenter -> #updateSelectionsFor:;
	add: #Presenter -> #updateSelectionsForUpdate:;
	add: #RowanCommandResult -> #classCategoryUpdate:;
	add: #RowanCommandResult -> #classCommentUpdate:;
	add: #RowanCommandResult -> #classDefinitionUpdate:;
	add: #RowanCommandResult -> #classesHierarchyUpdate:;
	add: #RowanCommandResult -> #classesUpdate:;
	add: #RowanCommandResult -> #classHierarchyUpdate:;
	add: #RowanCommandResult -> #classMethodsUpdate:;
	add: #RowanCommandResult -> #classUpdate:;
	add: #RowanCommandResult -> #dictionaryUpdate:;
	add: #RowanCommandResult -> #globalsUpdate:;
	add: #RowanCommandResult -> #methodFilterUpdate:;
	add: #RowanCommandResult -> #methodsUpdate:;
	add: #RowanCommandResult -> #packagesUpdate:;
	add: #RowanCommandResult -> #projectPackagesUpdate:;
	add: #RowanCommandResult -> #projectSelectionUpdate:;
	add: #RowanCommandResult -> #projectsUpdate:;
	add: #RowanCommandResult -> #superclassListUpdate:;
	add: #RowanCommandResult -> #updateClassCategorySelectionsFor:;
	add: #RowanCommandResult -> #updateClassHierarchySelectionFor:;
	add: #RowanCommandResult -> #updateClassSelectionFor:;
	add: #RowanCommandResult -> #updateDictionarySelectionsFor:;
	add: #RowanCommandResult -> #updateMethodFilterSelectionFor:;
	add: #RowanCommandResult -> #updateMethodSelectionFor:;
	add: #RowanCommandResult -> #updatePackageSelectionsFor:;
	add: #RowanCommandResult -> #updateSelectorFor:;
	add: #RowanCommandResult -> #updateSuperclassSelectionFor:;
	add: #RowanGsMethod -> #printOn:;
	add: #RowanMethodDefinition -> #methodDefinitionService;
	add: 'JadeServer class' -> #gsString;
	add: 'JadeServer64bit32 class' -> #gsClassDefinitionStringFor:;
	add: 'JadeSessionManager class' -> #getUrl;
	add: 'JadeSessionManager class' -> #mainShellClass;
	add: 'JadeSessionManager class' -> #setVersion;
	add: 'STON class' -> #fromStream:;
	add: 'STON class' -> #fromString:;
	add: 'STON class' -> #jsonWriter;
	add: 'STON class' -> #listClass;
	add: 'STON class' -> #mapClass;
	add: 'STON class' -> #put:asJsonOnStream:;
	add: 'STON class' -> #put:asJsonOnStreamPretty:;
	add: 'STON class' -> #put:onStream:;
	add: 'STON class' -> #put:onStreamPretty:;
	add: 'STON class' -> #reader;
	add: 'STON class' -> #toJsonString:;
	add: 'STON class' -> #toJsonStringPretty:;
	add: 'STON class' -> #toString:;
	add: 'STON class' -> #toStringPretty:;
	add: 'STON class' -> #writer;
	yourself.

package binaryGlobalNames: (Set new
	yourself).

package globalAliases: (Set new
	yourself).

package setPrerequisites: (IdentitySet new
	add: '..\Core\Object Arts\Dolphin\IDE\Base\Development System';
	add: '..\Core\Object Arts\Dolphin\Base\Dolphin';
	add: '..\Core\Object Arts\Dolphin\MVP\Views\Cards\Dolphin Card Containers';
	add: '..\Core\Object Arts\Dolphin\MVP\Presenters\Prompters\Dolphin Choice Prompter';
	add: '..\Core\Object Arts\Dolphin\MVP\Views\Common Controls\Dolphin Common Controls';
	add: '..\Core\Object Arts\Dolphin\MVP\Views\Control Bars\Dolphin Control Bars';
	add: '..\Core\Object Arts\Dolphin\MVP\Presenters\Prompters\Dolphin Key-Value Prompter';
	add: '..\Core\Object Arts\Dolphin\MVP\Models\List\Dolphin List Models';
	add: '..\Core\Object Arts\Dolphin\MVP\Presenters\List\Dolphin List Presenter';
	add: '..\Core\Object Arts\Dolphin\MVP\Deprecated\Dolphin MVP (Deprecated)';
	add: '..\Core\Object Arts\Dolphin\MVP\Base\Dolphin MVP Base';
	add: '..\Core\Object Arts\Dolphin\MVP\Presenters\Prompters\Dolphin Prompter';
	add: '..\Core\Object Arts\Dolphin\MVP\Presenters\Radio\Dolphin Radio Buttons';
	add: '..\Core\Object Arts\Dolphin\MVP\Presenters\Text\Dolphin Rich Text Presenter';
	add: '..\Core\Object Arts\Dolphin\MVP\Views\Scintilla\Dolphin Scintilla View';
	add: '..\Core\Object Arts\Dolphin\MVP\Views\Sliding Tray\Dolphin Slidey-Inney-Outey Thing';
	add: '..\Core\Object Arts\Dolphin\MVP\Presenters\Text\Dolphin Text Presenter';
	add: '..\Core\Object Arts\Dolphin\MVP\Models\Tree\Dolphin Tree Models';
	add: '..\Core\Object Arts\Dolphin\MVP\Type Converters\Dolphin Type Converters';
	add: '..\Core\Object Arts\Dolphin\MVP\Models\Value\Dolphin Value Models';
	add: '..\Core\Contributions\Burning River\ExternalProcess\ExternalProcess';
	add: 'GemStone C Interface';
	add: 'GemStone Objects';
	add: 'GemStone Services';
	add: 'GemStone Session';
	add: 'Jade Deployment';
	add: 'Jade Login';
	add: 'Jade Method Browser';
	add: 'Jade System Browser';
	add: 'Jade Test Browser';
	add: 'Jade Transcript';
	add: 'Jade UI Base';
	add: 'Monticello';
	add: 'Rowan STON';
	add: '..\Core\Object Arts\Dolphin\System\Compiler\Smalltalk Parser';
	add: '..\Core\Contributions\ITC Gorisek\Source Tracking System';
	add: '..\Core\Contributions\Solutions Software\SSW EditableListView';
	add: '..\Core\Contributions\Camp Smalltalk\SUnit\SUnit';
	yourself).

package!

"Class Definitions"!

Object subclass: #Rowan
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
Model subclass: #BrowserUpdate
	instanceVariableNames: 'updates debug'
	classVariableNames: 'Current'
	poolDictionaries: ''
	classInstanceVariableNames: ''!
Model subclass: #RowanService
	instanceVariableNames: 'transport remoteService name isDirty updates'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
RowanCommandResult subclass: #RowanClassCategoryUpdate
	instanceVariableNames: 'categories selection treeModel'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
RowanCommandResult subclass: #RowanClassesUpdate
	instanceVariableNames: 'classNames selectionNames'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
RowanCommandResult subclass: #RowanClassInfoUpdate
	instanceVariableNames: 'oop template category comment'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
RowanCommandResult subclass: #RowanDictionaryUpdate
	instanceVariableNames: 'dictionaries selections'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
RowanCommandResult subclass: #RowanGlobalsUpdate
	instanceVariableNames: 'globals'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
RowanCommandResult subclass: #RowanMethodUpdate
	instanceVariableNames: 'classOop className methodOop selector category editable source firstSendOffsets stepPoints breakPoints originalMethodSource compilationWarnings isTestClass isOverride gsMethod selected'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
RowanCommandResult subclass: #RowanPackageUpdate
	instanceVariableNames: 'packages modifiedPackages selections'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
RowanCommandResult subclass: #RowanProjectsUpdate
	instanceVariableNames: 'projects modifiedProjects selection'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
RowanClassesUpdate subclass: #RowanClassHierarchyUpdate
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
RowanClassesUpdate subclass: #RowanMethodsUpdate
	instanceVariableNames: 'methods methodFilters selectors selectedClass selectedSelectors inheritedClasses inheritedClass type'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
RowanClassesUpdate subclass: #RowanSuperclassUpdate
	instanceVariableNames: 'tabName'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
RowanService subclass: #RowanClassService
	instanceVariableNames: 'comment instVarNames classVarNames classInstVarNames superclassName subclassType poolDictionaryNames classType packageService meta isExtension version versions template oop allFilters filters filterType methods'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
RowanService subclass: #RowanMethodService
	instanceVariableNames: 'source selector methodDefinitions category packageName className meta user hasSupers hasSubs'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
RowanService subclass: #RowanPackageService
	instanceVariableNames: 'classes'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
RowanService subclass: #RowanProjectService
	instanceVariableNames: 'sha branch isSkew packages'
	classVariableNames: 'DefaultProjectName'
	poolDictionaries: ''
	classInstanceVariableNames: ''!
JadePresenterA subclass: #RowanPresenter
	instanceVariableNames: 'projectToolsOop'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
MethodSourcePresenter subclass: #RowanMethodSourcePresenter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
JadeMethodListPresenter subclass: #RowanMethodListPresenter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
JadeAutoSystemBrowserPresenter subclass: #RowanSystemBrowserPresenter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
RowanSystemBrowserPresenter subclass: #RowanProjectsBrowserPresenter
	instanceVariableNames: 'projectListPresenter stonCritical projectInfoTab projectLabel projectDictionaryTabs'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
MethodListPresenter subclass: #PackageMethodListPresenter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
RowanPresenter subclass: #RowanMethodSelectionPresenter
	instanceVariableNames: 'methodListPresenter methodSourcePresenter'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
RowanPresenter subclass: #RowanPackagePresenter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
RowanPresenter subclass: #RowanProjectListPresenter
	instanceVariableNames: 'projectListPresenter'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
KeyValuePrompter subclass: #RowanKeyValuePrompter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
MCVersionDialog subclass: #RowanSavePackageDialog
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
JadeLoginShell subclass: #RowanLoginShell
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
JadeTranscript subclass: #RowanTranscript
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
JadeShell subclass: #RowanShell
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
JadeMethodListBrowser subclass: #RowanMethodListBrowser
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
JadeSystemBrowser subclass: #RowanSystemBrowser
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
RowanSystemBrowser subclass: #RowanProjectsSystemBrowser
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
MCPatchBrowser subclass: #RowanPatchBrowser
	instanceVariableNames: 'name'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
RowanShell subclass: #RowanPackageShell
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
RowanShell subclass: #RowanProjectListShell
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
TestCase subclass: #RowanServiceTest
	instanceVariableNames: 'shell methodService gciSession classService'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

"Global Aliases"!


"Loose Methods"!

!CodeSourcePresenter methodsFor!

browseSelectedClass
	| range string list assoc parent shell |
	range := documentPresenter view selectionRange.
	string := documentPresenter value copyFrom: range start to: range stop.
	list := self findClassList.
	assoc := list detect: [:each | each key = string]
				ifNone: [^MessageBox warning: 'Class ' , string printString , ' not found!!!!' caption: 'Jade'].
	parent := parentPresenter parentPresenter parentPresenter.
	parent isNil
		ifTrue: 
			[shell := RowanSystemBrowser showOnSession: gciSession.
			shell selectClass: string selector: String new]
		ifFalse: [parent addSystemBrowserForClass: assoc value]! !
!CodeSourcePresenter categoriesFor: #browseSelectedClass!public! !

!GciSession methodsFor!

hasServer

	^server notNil.
!

initializeServer
"
	GciSession allInstances first initializeServer.
"
	library ifNil: [^self].
	[
		server := self executeString: library jadeServerClass gsString.
	] on: GsRuntimeError do: [:ex | 
		| number notes |
		number := ex errorReport number.
		notes := ''.
		number = 2151 ifTrue: [notes := ' (code modification?)'].
		MessageBox warning: ex description , notes , '
Server initialization failed. Most functionality will be broken!!'.
		SessionManager current pause.
		ex return: nil.
	].

	(server isKindOf: String) ifTrue: [
		self logout.
		GciLoginFailed
			signal: 'JadeServer compile error:
' , server
			with: self.
	].
	self commit.

	1 ~~ 1 ifTrue: [		"messasges that are sent by a ClientForwarderSend should not be stripped"
		self 
			signalConfirmationRequestUsing: nil;
			signalTextRequestUsing: nil;
			yourself.
	].
!

postLoginAs: aString useSocket: aBoolean
	self verifyRowanLoaded ifFalse: [^MessageBox notify: 'Rowan not loaded or $ROWAN_PROJECTS_HOME not set. Logging out.' "log out in RowinLoginShell>>postLogin:"].
	"self initializeServer."
	server := self executeString: '| server | 
			server := JadeServer64bit32 new initialize; yourself.
			System _sessionStateAt: 3 put: server.
			^server'.
	aBoolean ifTrue: [self attemptSocket].
	self setInitials: aString	"This gets back the session and serial number"!

titleBarFor: aString
"'Jade ' , gciSession gciSessionID printString , ' (' , gciSession userID , ') - "
	| stream list |
	list := stoneNRS subStrings: $!!.
	stoneName := list at: 3.
	list := (list at: 2) subStrings: $#.
	list := (list at: 1) subStrings: $@.
	stoneHost := list at: 2.
	stream := WriteStream on: String new.
	stream 
		nextPutAll: 'Jadeite version [';
		nextPutAll: JadeSessionManager shortVersion;
		nextPutAll: '] ' ;
		print: gciSessionId;
		nextPutAll: ' (';
		nextPutAll: userID;
		nextPutAll: ') - ';
		nextPutAll: aString;
		nextPutAll: ' on ';
		nextPutAll: stoneName;
		nextPutAll: ' session ';
		print: stoneSessionID;
		nextPutAll: ' on ';
		nextPutAll: stoneHost;
		yourself.
	self isRemoteGem ifTrue: [
		list := gemNRS subStrings: $#.
		netPort := ((list at: 2) subStrings: $:) at: 2.
		netTask := ((list at: 3) subStrings: $!!) at: 2.
		gemHost := ((list at: 1) subStrings: $@) at: 2.
		stream
			nextPutAll: ' with remote gem on ';
			nextPutAll: gemHost;
			yourself.
	] ifFalse: [
		stream nextPutAll: ' with linked gem'. 
	].
	^stream contents.
!

verifyRowanLoaded
	"The global Rowan indicates the Rowan packages are loaded. 
	The ROWAN_PROJECTS_HOME gem environment variable is also required"

	^self
		executeString: '(System myUserProfile objectNamed: ''Rowan'') notNil and:[(System gemEnvironmentVariable: ''ROWAN_PROJECTS_HOME'') notNil] '! !
!GciSession categoriesFor: #hasServer!public! !
!GciSession categoriesFor: #initializeServer!private! !
!GciSession categoriesFor: #postLoginAs:useSocket:!private! !
!GciSession categoriesFor: #titleBarFor:!public! !
!GciSession categoriesFor: #verifyRowanLoaded!private! !

!GsMethod methodsFor!

methodDefinitionService
	^RowanMethodService on: gciSession! !
!GsMethod categoriesFor: #methodDefinitionService!public!rowan! !

!JadeImageStripper methodsFor!

closeLoginShells

	JadeLoginShell allInstances do: [:each | each view close].
	RowanLoginShell allInstances do: [:each | each view close].

!

createVersionResource
"
	JadeImageStripper new createVersionResource.
"
	| versionString version |
	versionString := JadeSessionManager getVersion.
	version := (versionString subStrings: $-) first.
	self versionResource
		fileVersion: version;
		productVersion: version;
		stringTables: (LookupTable new
			at: '040904b0' 
			put: (LookupTable new
				at: 'CompanyName' 		put: 'GemTalk Systems LLC';
				at: 'FileDescription' 		put: 'IDE for GemStoneS/64 with Rowan Source Code Control';
				at: 'FileVersion' 			put: versionString;
				at: 'InternalName' 		put: 'Jadeite';
				at: 'LegalCopyright' 		put: 'Copyright © GemTalk Systems 2018';
				at: 'OriginalFilename' 	put: 'Jadeite.exe';
				at: 'ProductName' 		put: 'Jadeite';
				at: 'ProductVersion' 		put: versionString;
				yourself);
			yourself);
		yourself.
!

requiredClasses
	^(super requiredClasses)
		addAll: JadeServer withAllSubclasses;
		addAll: GciError withAllSubclasses;
		addAll: GsError withAllSubclasses;
		addAll: GciLibrary withAllSubclasses;
		addAll: GsHostProcess withAllSubclasses;
		addAll: GsShellCommand withAllSubclasses;
		addAll: GsWin32Service withAllSubclasses;
		add: NTLibrary;
		add: StParseNodeVisitor;
		addAll: StProgramNode withAllSubclasses;
		addAll: StToken withAllSubclasses;
		add: ScintillaIndicator;
		add: WaitOnGemStoneDialog;
		yourself!

requiredPackageNames

	^super requiredPackageNames
		add: 'Development System'; 		"to get StKeywordToken>>#preComments"
		add: 'GemStone C Interface';
		add: 'GemStone Session';
		add: 'GemStone Objects';
		add: 'GemStone Services';
		add: 'Jade Inspector';
		add: 'Jade Login';
		add: 'Jade System Browser';
		add: 'Jade Transcript';
		add: 'Jade User Browser';
		add: 'JGF Dolphin';
		add: 'JGF Dolphin MVP Base';
		add: 'JGF Fading Dialog';
		add: 'Jade UI';
		add: 'Object Log Browser';
		add: 'Jade from Dolphin';
		add: 'Jade Process Browser';
		add: 'Rowan UI Base';
		add: 'Rowan STON';
		add: 'Dolphin Announcements';
		yourself! !
!JadeImageStripper categoriesFor: #closeLoginShells!public! !
!JadeImageStripper categoriesFor: #createVersionResource!public! !
!JadeImageStripper categoriesFor: #requiredClasses!public! !
!JadeImageStripper categoriesFor: #requiredPackageNames!public! !

!JadeLoginShell methodsFor!

aboutJadeite
	"See also JadeTextDocument>>#'aboutJadeite'"

	self class aboutJadeite! !
!JadeLoginShell categoriesFor: #aboutJadeite!public! !

!JadePresenterA methodsFor!

browseImplementorsOf: aGsMethodOrString
	
	(parentPresenter class = JadeTreeMethodListPresenter) ifTrue: [^parentPresenter browseImplementorsOf: aGsMethodOrString].

	^(RowanMethodListBrowser showOnSession: self gciSession) primaryPresenter
		browseImplementorsOf: aGsMethodOrString;
		yourself.
!

browseSendersOf: aGsMethodOrString

	(parentPresenter class = JadeTreeMethodListPresenter) ifTrue: [^parentPresenter browseSendersOf: aGsMethodOrString].

	(JadeMethodListBrowser showOnSession: self gciSession) primaryPresenter
		browseSendersOf: aGsMethodOrString;
		yourself.
! !
!JadePresenterA categoriesFor: #browseImplementorsOf:!public! !
!JadePresenterA categoriesFor: #browseSendersOf:!public! !

!JadeServer methodsFor!

_describeMethod: aMethod
	"Provide info needed to create a GsMethod in Jade client"
	"Nice to add packageName and mcTimestamp"

	| allSelectors class list oldGsMethod string methodUpdate |
	methodUpdate := RowanMethodUpdate new method: aMethod. 
	self environment: (self environmentForMethod: aMethod).
		
	methodUpdate 	"Line 1 for GsMethod (line 3 for JadeSystemBrowserPresenter)"
"1"		classOop: (class := aMethod inClass) asOop;
"2"		className: class printString;
"3"		methodOop: aMethod asOop;
"4"		selector: aMethod selector;
"5"		category: (self categoryOfMethod: aMethod);
"6"		isReadOnly: (self currentUserMayEditMethod: aMethod);
			source: aMethod sourceString.

	"unimplemented selectors"			"https://github.com/jgfoster/Jade/issues/117"
	((aMethod class includesSelector: #'_selectorPool') and: [aMethod class includesSelector: #'_sourceOffsetOfFirstSendOf:']) ifTrue: [
		allSelectors := self _allSelectors.
		(aMethod _selectorPool reject: [:each | allSelectors includes: each]) do: [:each | 
			methodUpdate firstSendOffsets at: (aMethod _sourceOffsetOfFirstSendOf: each) put: each.
		].
	].

	"Array of Associations (offset -> selector) indexed by step points"
	list := self sbUpdateMethodStepPointsFor: aMethod.
	list do:[:each | methodUpdate stepPoints at: each key printString put: each value].

	"breaks"
	methodUpdate breakPoints: (self sbUpdateMethodBreakPointsFor: aMethod).

	"original method"
	oldGsMethod := (aMethod inClass class canUnderstand: #'persistentMethodDictForEnv:')
		ifTrue: [(aMethod inClass persistentMethodDictForEnv: 0) at: aMethod selector ifAbsent: [aMethod]]
		ifFalse: [(aMethod inClass class canUnderstand: #'_rawMethodDict')
			ifTrue: [aMethod inClass _rawMethodDict at: aMethod selector ifAbsent: [aMethod]]
			ifFalse: [aMethod]].
	aMethod ~~ oldGsMethod ifTrue: [
		methodUpdate originalMethodSource: oldGsMethod sourceString.
	].

	"method compile warnings"
	string := selections isNil 
		ifTrue: ['']
		ifFalse: [selections at: #'methodWarnings' ifAbsent: ['']].
	string isNil ifTrue: [string := ''].
	methodUpdate compilationWarnings: string.
	methodUpdate writeMethodTo: writeStream.

 
!

sbAddPackage: anOrderedCollection
	| string service |
	string := anOrderedCollection removeFirst.
	selections at: #package put: string.
	service := Rowan packageServiceClass forPackageNamed: string.
	service createPackage.
	self systemBrowserUpdate!

sbChangesInPackage: anOrderedCollection
	"where anOrderedCollection is {packageName, projectName}"

	| patch string packageName url |
	packageName := anOrderedCollection removeFirst.
	url := anOrderedCollection removeFirst.
	patch := Rowan packageTools diff patchForPackageName: packageName.
	string := self
				_mcDescriptionOfPatch: patch
				baseName: 'closest ancestor'
				alternateName: nil.
	writeStream
		nextPutAll: 'changesInPackage';
		lf;
		nextPutAll: string;
		yourself
!

sbClassTemplate
	| def service classInfoUpdate |
	service := Rowan classServiceClass forClassNamed: 'Object'.
	def := service classCreationTemplate.
	classInfoUpdate := RowanClassInfoUpdate new.
	classInfoUpdate 
		oop: 0;
		template: def.
	classInfoUpdate writeInfoOn: writeStream
!

sbRemoveClasses
	| isPackages containers classNames |
	self nextLine = 'packageList'. "ignore this" 
	containers := self nextLineAsList.
	classNames := (self nextLineAsList reject: [:each | each isEmpty])
				collect: [:each | (each subStrings: Character space) first asSymbol].
	containers do: 
			[:packageName |
			classNames
				do: [:className | (Rowan packageServiceClass forPackageNamed: packageName) removeClassNamed: className]].
	^self systemBrowserUpdate!

sbRemoveMethods: anOrderedCollection
	| behavior classEntity  notRemoved|
	behavior := self sbClassFrom: anOrderedCollection.
	classEntity := ((System myUserProfile resolveSymbol: #UserGlobals) value at: #rowanCompile
				ifAbsent: [false])
					ifTrue: [Rowan classServiceClass forClassNamed: behavior name meta: behavior isMeta]
					ifFalse: [behavior].
	notRemoved := Array new. 
	anOrderedCollection do: [:each | classEntity removeSelector: each asSymbol ifAbsent: [notRemoved add: each]].
	self systemBrowserUpdate.
	notRemoved isEmpty ifFalse:[self error: 'The following selectors were not removed. Possibly in a superclass? ', notRemoved printString].!

sbUnloadPackage: anOrderedCollection
	| service |
	service := Rowan packageServiceClass forPackageNamed: anOrderedCollection removeFirst.
	service deletePackage.
	self systemBrowserUpdate!

sbUpdateClassCategories

	| categories selection override categoryUpdate |
	categoryUpdate := RowanClassCategoryUpdate new. 
	categories := Set new.
	classList do: [:each | categories add: each category].
	categoryUpdate categories addAll: categories asSortedCollection.
	categoryUpdate writeCategoriesTo: writeStream.
	selection := self nextLine.
	categoryUpdate selection: selection. 
	(override := selections at: #'category' ifAbsent: [nil]) notNil ifTrue: [selection := override , '-'].
	selection := 1 < selection size 
		ifTrue: [selection copyFrom: 1 to: selection size - 1]
		ifFalse: [''].
	selection notEmpty ifTrue: [
		categories := categories select: [:each | (each copyFrom: 1 to: (each size min: selection size)) = selection].
		categories isEmpty ifTrue: [selection := ''].
		categories notEmpty ifTrue: [
			classList := classList select: [:each | categories includes: each category].
		].
	].
	categoryUpdate writeSelectionTo: writeStream.

!

sbUpdateClassHierarchy

	| currentSelection currentClass  override classHierarchyUpdate |
	
	classHierarchyUpdate := RowanClassHierarchyUpdate new. 
	classList do: [:each | 
		classHierarchyUpdate addHierarchyFor: each
	].
	classHierarchyUpdate writeHierarchyTo: writeStream. 
	"now figure out which class to select"
	currentSelection := self nextLineAsList.
	(override := selections at: #'className' ifAbsent: [nil]) notNil ifTrue: [currentSelection := Array with: override].
	currentSelection isEmpty ifTrue: [
		selectedClass := nil.
	] ifFalse: [
		(currentClass := selections at: #'class' ifAbsent: [nil]) isNil ifTrue: [
			| className |
			className := (currentSelection last subStrings: Character space) first asSymbol.
			selectedClass := classHierarchyUpdate allClasses detect: [:each | each name = className] ifNone:[].
		] ifFalse: [
			selectedClass := nil.
			[
				selectedClass isNil and: [currentClass notNil].
			] whileTrue: [
				selectedClass := classHierarchyUpdate allClasses detect: [:each | each = currentClass] ifNone:[].
				currentClass := currentClass superclass.
			].
		].
	].
	classHierarchyUpdate addSelectionHierarchyFor: selectedClass.
	classHierarchyUpdate writeSelectionHierarchyTo: writeStream.
	classHierarchyUpdate writeTestCaseInfoTo: writeStream.


!

sbUpdateClassInfo
	| classComment classInfoUpdate |
	selectedClass isNil ifTrue: [^self sbClassTemplate].
	classInfoUpdate := RowanClassInfoUpdate new. 
	classInfoUpdate oop: (self oopOf: selectedClass).
	classInfoUpdate template: (Rowan classServiceClass forClassNamed: selectedClass name)
							classCreationTemplate.
	classInfoUpdate category: ((classInfoUpdate template includesString: 'category: ''')
					ifFalse: [' category: ' , selectedClass category printString]).
	(selectedClass class canUnderstand: #comment)
		ifTrue: [classComment := selectedClass comment]
		ifFalse: 
			[(selectedClass class canUnderstand: #description)
					ifTrue: 
						[| description |
						description := selectedClass description.
						description class name = #GsClassDocumentation
							ifTrue: [classComment := description detailsAboutClass]]].
	classComment isNil ifTrue: [classComment := ''].
	classInfoUpdate comment: classComment. 
	classInfoUpdate writeInfoOn: writeStream.
!

sbUpdateClassList

	| mySelections override classesUpdate |
	classesUpdate := RowanClassesUpdate new. 
	(classList asSortedCollection: [:a :b | a name <= b name]) do: [:eachClass | 
		classesUpdate classNames add: eachClass name. 
	].
	classesUpdate writeClassesTo: writeStream. 
	mySelections := self nextLineAsList collect: [:each | (each subStrings: Character space) first asSymbol].
	(override := selections at: #'className' ifAbsent: [nil]) notNil ifTrue: [mySelections := Array with: override].
	mySelections := classList select: [:eachClass | mySelections includes: eachClass name].
	mySelections do: [:eachClass | 
		classesUpdate selections add: eachClass asString].
	classesUpdate writeSelectionsTo: writeStream. 
	classesUpdate writeTestCaseInfoTo: writeStream. 
	selectedClass := mySelections size = 1
		ifTrue: [mySelections first]
		ifFalse: [nil].
!

sbUpdateDictionaries

	| override packagePolicy home symbolList oldSelections newSelections fullList globals dictionaryUpdate globalsUpdate |
	dictionaryUpdate := RowanDictionaryUpdate new. 
	oldSelections := self nextLineAsList.
	(override := selections at: #'dictionary' ifAbsent: [nil]) notNil ifTrue: [oldSelections := Array with: override].
	symbolList := self symbolList.
	(packagePolicy := self gsPackagePolicy) notNil  ifTrue: [
		home := packagePolicy homeSymbolDict.
	].
	fullList := symbolList collect: [:each | 
		| hvName | 
		hvName := (each == home ifTrue: ['H'] ifFalse: ['V']) , each name.
		dictionaryUpdate dictionaries add: hvName.
		hvName.
		].
	dictionaryUpdate writeDictionariesTo: writeStream.
	fullList := fullList collect: [:each | each copyFrom: 2 to: each size].
	newSelections := oldSelections select: [:each | fullList includes: each].
	globals := Dictionary new.
	newSelections do: [:eachName | 
		| symbolDictionary globalKeyPrefix |
		globalKeyPrefix := 1 < newSelections size ifTrue: [eachName , '.'] ifFalse: [''].
		dictionaryUpdate selections add: eachName asString.
		symbolDictionary := symbolList at: (fullList indexOf: eachName).
		symbolDictionary keys asSortedCollection do: [:eachKey |
			| eachGlobal |
			eachGlobal := symbolDictionary at: eachKey.
			(eachGlobal isBehavior and: [eachGlobal name == eachKey])
				ifTrue: [classList add: eachGlobal]
				ifFalse: [globals at: globalKeyPrefix , eachKey put: (symbolDictionary associationAt: eachKey)].
		].
	].
	dictionaryUpdate writeSelectionsTo: writeStream. 
	globalsUpdate := RowanGlobalsUpdate new. 
	globals keys asSortedCollection do: [:eachKey | 
		| eachAssociation eachValue string globalsArray |
		eachAssociation := globals at: eachKey.
		eachValue := eachAssociation value.
		string := self asString: eachValue.
		100 < string size ifTrue: [string := string copyFrom: 1 to: 100].
		string := string collect: [:char | (char asciiValue < 32 or: [127 < char asciiValue]) ifTrue: [$.] ifFalse: [char]].
		string := String withAll: string asArray.
		globalsArray := Array new. 
		globalsArray add: eachKey;
						add: eachValue _class name;
						add: string;
						add: (self oopOf: eachValue) printString;
						add: (self oopOf: eachAssociation) printString.
		globalsUpdate globals add: globalsArray. 
	].
	globalsUpdate writeGlobalsTo: writeStream.
	

!

sbUpdateMethodCategories

	| methodUpdate | 
	methodUpdate := RowanMethodsUpdate new.  
	methodUpdate classNamesFrom: classList. 
	methodUpdate updateMethodCategories; 
		writeMethodCategoriesTo: writeStream. 
	methodUpdate updateMethodSelections: self nextLineAsList 
			hasCategoryOverride: (selections at: #'methodCategory' ifAbsent: [nil]).
	methodFilters := methodUpdate methodFilters.
	methodUpdate writeSelectionsTo: writeStream. !

sbUpdateMethods

	| selectors methodUpdate |
	selectedClass isNil ifTrue: [^self].
	methodUpdate := RowanMethodsUpdate new selectedClass: selectedClass.
	methodFilterType = 'categoryList' ifTrue: [selectors := self sbUpdateMethodsByCategories] ifFalse: [
	methodFilterType = 'variableList' ifTrue: [selectors := self sbUpdateMethodsByVariables] ifFalse: [
	methodFilterType = 'pragmaList' ifTrue: [selectors := self sbUpdateMethodsByPragmas] ifFalse: [
		self error: 'Unrecognized methodFilterType: ' , methodFilterType printString]]].
	methodUpdate selectors: selectors asSortedCollection.
	methodUpdate updateMethodsInfo.
	methodUpdate writeMethodsTo: writeStream. 
	self sbUpdateMethodSelectionsIn: methodUpdate
!

sbUpdateMethodVariables

	| methodUpdate |
	methodUpdate := RowanMethodsUpdate new. 
	methodUpdate classNamesFrom: classList. 
	methodUpdate updateMethodVariables. 
	methodUpdate writeMethodFiltersTo: writeStream. 
	methodUpdate updateMethodSelections: self nextLineAsList 
		hasCategoryOverride: (selections at: #'methodCategory' ifAbsent: [nil]).
	methodFilters := methodUpdate methodFilters.
	methodUpdate writeSelectionsTo: writeStream. 

!

sbUpdatePackages
	| override modifiedList oldSelections newSelections fullList packagesUpdate |
	
	packagesUpdate := RowanPackageUpdate new. 
	oldSelections := self nextLineAsList.
	(override := selections at: #package ifAbsent: [nil]) notNil
		ifTrue: [oldSelections := Array with: override].
	fullList := Rowan serviceClass new rowanLoadedPackageNames subStrings: Character lf.
	fullList := fullList reject: [:each | each isEmpty].
	fullList := fullList asSortedCollection asArray.
	fullList := fullList collect: [:each | each subStrings: Character tab].
	fullList := fullList reject: [:each | each isEmpty].
	modifiedList := (fullList select: [:each | (each at: 2) = 'Y']) collect: [:each | each at: 3].
	fullList := fullList collect: [:each | each at: 3].
	packagesUpdate modifiedPackages addAll: modifiedList. 
	packagesUpdate packages addAll: fullList. 
	packagesUpdate writePackagesTo: writeStream. 
	packagesUpdate writeModifiedPackagesTo: writeStream. 
	newSelections := oldSelections select: [:each | fullList includes: each].
	(newSelections isEmpty and: [oldSelections size = 1])
		ifTrue: 
			[newSelections := fullList
						select: [:each | (oldSelections first copyFrom: 1 to: (oldSelections first size min: each size)) = each]].
	newSelections do: 
			[:each |
			| service |
			packagesUpdate selections add: each asString. 
			service := Rowan packageServiceClass forPackageNamed: each.
			classList addAll: service loadedClassHandles].
	packagesUpdate writeSelectionsTo: writeStream.
	newSelections size = 1 ifTrue: [self sbUpdatePackage: newSelections first]
!

sbUpdateSuperclass

	| class tabName selected index superclassUpdate |
	superclassUpdate := RowanSuperclassUpdate new.
	tabName := self nextLine. 
	(#('default' 'instanceTab' 'classTab') includes: tabName) ifFalse: [self error: 'Unexpected token!!'].
	tabName = 'default' ifTrue: [
		tabName := (selectedClass notNil and: [selectedClass selectors isEmpty and: [selectedClass class selectors notEmpty]]) 
			ifTrue: ['classTab']
			ifFalse: ['instanceTab'].
	].
	superclassUpdate tabName: tabName. 
	superclassUpdate writeTabNameTo: writeStream.
	selectedClass notNil ifTrue: [
		selectedClass := tabName = 'instanceTab'
			ifTrue: [selectedClass]
			ifFalse: [selectedClass class].
	].
	class := selectedClass.
	classList := OrderedCollection new.
	[
		class notNil.
	] whileTrue: [
		classList add: class.
		superclassUpdate classNames add: class name. 
		class := self environmentSuperClassFor: class.
	].
	superclassUpdate writeClassesTo: writeStream.
	classList := classList reverse.
	selected := self nextLine.
	index := classList findFirst: [:each | each name asString = selected].
	index = 0 ifTrue: [index := classList size].
	0 < index ifTrue: [classList := classList copyFrom: index to: classList size].
	classList notEmpty ifTrue: [
		selectedClass := classList first.
		superclassUpdate selections add: selectedClass asString.
	].
	superclassUpdate writeSelectionsTo: writeStream. 
! !
!JadeServer categoriesFor: #_describeMethod:!Debugger!GsObject!public!System Browser! !
!JadeServer categoriesFor: #sbAddPackage:!public!System Browser! !
!JadeServer categoriesFor: #sbChangesInPackage:!public!System Browser! !
!JadeServer categoriesFor: #sbClassTemplate!public!System Browser! !
!JadeServer categoriesFor: #sbRemoveClasses!public!System Browser! !
!JadeServer categoriesFor: #sbRemoveMethods:!public!System Browser! !
!JadeServer categoriesFor: #sbUnloadPackage:!public!System Browser! !
!JadeServer categoriesFor: #sbUpdateClassCategories!public!System Browser! !
!JadeServer categoriesFor: #sbUpdateClassHierarchy!public!System Browser! !
!JadeServer categoriesFor: #sbUpdateClassInfo!public!System Browser! !
!JadeServer categoriesFor: #sbUpdateClassList!public!System Browser! !
!JadeServer categoriesFor: #sbUpdateDictionaries!public!System Browser! !
!JadeServer categoriesFor: #sbUpdateMethodCategories!public!System Browser! !
!JadeServer categoriesFor: #sbUpdateMethods!public!System Browser! !
!JadeServer categoriesFor: #sbUpdateMethodVariables!public!System Browser! !
!JadeServer categoriesFor: #sbUpdatePackages!public!System Browser! !
!JadeServer categoriesFor: #sbUpdateSuperclass!public!System Browser! !

!JadeServer class methodsFor!

gsString
"
	JadeServer64bit3x gsString.
"
	| stream |
	SessionManager current isRuntime ifTrue: [^gsString].
	(stream := WriteStream on: String new)
		nextPutAll: '| class mcPlatformSupport methodClass readStream result server source symbolList writeStream |'; lf;
		nextPutAll: 'methodClass := ';
		nextPutAll: self gsMethodClassName;
		nextPut: $.; lf;
		nextPutAll: 'symbolList := System myUserProfile symbolList.'; lf;
		
		" These lines force OtherPassword setting to be enabled to run Jadeite. (OtherPassword is required to change another symbol list.
		nextPutAll: 'symbolList := (AllUsers userWithId: ''DataCurator'') symbolList.'; lf;
		nextPutAll: 'symbolList := symbolList class new add: (symbolList detect: [:each | each name == #UserGlobals]); add: (symbolList detect: [:each | each name == #Globals]); yourself.'; lf;"

		nextPutAll: '[class := symbolList objectNamed: #Object.'; lf;
		yourself.
	(self withAllSuperclasses remove: Object; yourself) reverseDo: [:eachClass | self addGsStringForClass: eachClass to: stream].
	stream 
		nextPutAll: '(mcPlatformSupport := symbolList objectNamed: #''MCPlatformSupport'') notNil ifTrue: ['; lf;
		nextPutAll: '	mcPlatformSupport autoCommit: false; autoMigrate: false].'; lf;
		nextPutAll: 'class := ((symbolList objectNamed: #System) myUserProfile symbolList objectNamed: #UserGlobals) at: #' , self name , ' ifAbsent: [class].'; lf;
		nextPutAll: 'server := class new initialize; yourself.'; lf;
		nextPutAll: self sessionStateCode; lf;
		nextPutAll: 'server] on: (symbolList objectNamed: #Error) do: [:ex | ex return: ''ERROR: '' , (GsProcess stackReportToLevel: 100)]';
		yourself.
	gsString := stream contents.
	^gsString.
! !
!JadeServer class categoriesFor: #gsString!public! !

!JadeServer64bit methodsFor!

recompile: aMethod withSource: aString
	| result behavior |
	behavior := aMethod inClass.
	((System myUserProfile resolveSymbol: #UserGlobals) value at: #rowanCompile ifAbsent: [false])
		ifTrue: 
			[behavior rwCompileMethod: aString
				category: (self _behavior: behavior categoryOfSelector: aMethod selector).
			Rowan serviceClass rowanFixMe.	"need to handle compile errors"
			^true]
		ifFalse: 
			[result := aMethod _recompileWithSource: aString.
			result isNil ifTrue: [^true].	"Bug 41195 returns nil if success so assume it is the same method"
			^result]!

systemBrowserSTON: aString

	[
		^super systemBrowserSTON: aString.
	] on: Error do: [:ex |
		readStream := nil.
		ex pass.
	].
! !
!JadeServer64bit categoriesFor: #recompile:withSource:!Debugger!public! !
!JadeServer64bit categoriesFor: #systemBrowserSTON:!public!System Browser! !

!JadeServer64bit32 class methodsFor!

gsClassDefinitionStringFor: aClass
	"Some class variables exist only in Dolphin and map to globals in GemStone; others exist only in GemStone and map to globals in Dolphin!!"

	^'class subclass: ''' , aClass name , '''
		instVarNames: ' , aClass instVarNames printString , '
		classVars: #(' , aClass classVarsForGemStone , ')
		classInstVars: #()
		poolDictionaries: (#() class withAll: symbolList)
		inDictionary: UserGlobals.'
! !
!JadeServer64bit32 class categoriesFor: #gsClassDefinitionStringFor:!public! !

!JadeServer64bit3x methodsFor!

compileMethod: methodString behavior: aBehavior symbolList: aSymbolList inCategory: categorySymbol
	"returns (nil -> anArrayOfErrors) or (aGsNMethod -> compilerWarnings) or (aGsNMethod -> nil)"

	| method warnings | 

	[[((System myUserProfile resolveSymbol: #UserGlobals) value at: #rowanCompile ifAbsent:[false]) ifTrue:[
			method := aBehavior rwCompileMethod: methodString category: categorySymbol]
		ifFalse:[
			method := aBehavior
			compileMethod: methodString
			dictionaries: aSymbolList
			category: categorySymbol
			environmentId: environment].
	] on: CompileError do: [:ex |
		^nil -> (ex gsArguments at: 1)
	]] on: CompileWarning do: [:ex |
		warnings := ex gsArguments at: 1.
		ex resume.
	].
	^[	
		(self compiledMethodAt: method key selector inClass: aBehavior) -> warnings.
	] on: Error do: [:ex | 
		ex return: method -> warnings.
	].
!

sbClassComment: anOrderedCollection

	(self sbClassFrom: anOrderedCollection) thisClass rwComment: self sbNextParagraph trimSeparators.
	self systemBrowserUpdate.
!

sbUpdateMethodPragmas

	| methodUpdate |
	methodUpdate := RowanMethodsUpdate new. 
	selectedClass notNil ifTrue:[
		methodUpdate selections add: selectedClass asString].
	methodUpdate updateMethodPragmas.
	methodUpdate writeMethodFiltersTo: writeStream. 
	methodUpdate updateMethodSelections: self nextLineAsList 
		hasCategoryOverride: (selections at: #'methodCategory' ifAbsent: [nil]).
	methodFilters := methodUpdate methodFilters.
	methodUpdate writeSelectionsTo: writeStream. 

! !
!JadeServer64bit3x categoriesFor: #compileMethod:behavior:symbolList:inCategory:!Methods!public!System Browser! !
!JadeServer64bit3x categoriesFor: #sbClassComment:!public!System Browser! !
!JadeServer64bit3x categoriesFor: #sbUpdateMethodPragmas!public!System Browser! !

!JadeSessionManager class methodsFor!

getUrl
	"no longer sent, but might be handy to have"

	| string |
	string := [SessionManager current class git: 'config --get remote.origin.url']
				on: ExternalProcessExecuteError
				do: [:ex | ^'???'].
	^(ReadStream on: string) nextLine!

mainShellClass

	^RowanLoginShell.
!

setVersion

	Version := self getVersion.! !
!JadeSessionManager class categoriesFor: #getUrl!public! !
!JadeSessionManager class categoriesFor: #mainShellClass!public! !
!JadeSessionManager class categoriesFor: #setVersion!public! !

!JadeSystemBrowserPresenter methodsFor!

browseMethodsAndSelect: aString

	(RowanMethodListBrowser showOnSession: self gciSession) primaryPresenter
		browseMethodsFromString: readStream upToEnd methodName: aString;
		selecting: aString.
!

browseMethodsAndSelect: aString type: browseType

	(RowanMethodListBrowser showOnSession: self gciSession) primaryPresenter
		browseMethodsFromString: readStream upToEnd methodName: aString type: browseType;
		selecting: aString.
!

onViewOpened 
	super onViewOpened.
	categoryListPresenter view contextMenu: (Menu fromStrings: self categoriesMenuStrings).
	classCommentPresenter view isReadOnly: false.
	classHierarchyPresenter view contextMenu: (Menu fromStrings: self classesMenuStrings).
	classListPresenter view contextMenu: (Menu fromStrings: self classesMenuStrings).
	dictionaryListPresenter view contextMenu: (Menu fromStrings: self dictsMenuStrings).
	globalsPresenter view contextMenu: (Menu fromStrings: self globalsMenuStrings).
	methodListPresenter view contextMenu: (Menu fromStrings: self methodsMenuStrings).
	methodSourcePresenter view
		contextMenu: (Menu fromStrings: self editMenuStrings);
		isBackgroundDwellEnabled: true;
		isBraceHighlightingEnabled: true;
		yourself.
	packageListPresenter view contextMenu: (Menu fromStrings: self pkgsMenuStrings).
	variableListPresenter view contextMenu: (Menu fromStrings: self variablesMenuStrings).
	self setSearchPolicy.
	!

packageTabName

	^'Packages'!

queryCommand: aCommandQuery

	| command focusView isTextEdit |
	command := aCommandQuery command.
	focusView := View focus.
	isTextEdit := focusView isKindOf: TextEdit.
	(#(#'browseMethodPragmas') includes: command) ifTrue: [aCommandQuery isEnabled: gciSession gsHasPragmas. ^true].
	(#(#'editSave') includes: command) ifTrue: [aCommandQuery isEnabled: (isTextEdit and: [focusView isModified]). ^true].
	(#(#'editUndo') includes: aCommandQuery command) ifTrue: [aCommandQuery isEnabled: (isTextEdit and: [focusView canUndo]). ^true].
	(#(#'editRedo') includes: aCommandQuery command) ifTrue: [aCommandQuery isEnabled: (isTextEdit and: [focusView canRedo]). ^true].
	(#(#'editCut' #'editCopy' "#'editDelete'" ) includes: aCommandQuery command) ifTrue: [aCommandQuery isEnabled: (isTextEdit and: [focusView hasSelection]). ^true].
	(#(#'editPaste') includes: aCommandQuery command) ifTrue: [aCommandQuery isEnabled: (isTextEdit and: [Clipboard current isTextAvailable]). ^true].
	(#(#'addRepository') includes: command) ifTrue: [aCommandQuery isEnabled: packageListPresenter selections notEmpty. ^true].
	(#(#'showPackageChanges') includes: command) ifTrue: [
		aCommandQuery isEnabled: true . ^true].
	(#(#'savePackage') includes: command) ifTrue: [aCommandQuery isEnabled: packageListPresenter selections size = 1. ^true].
	(#(#'removeRepository') includes: command) ifTrue: [
		aCommandQuery isEnabled: (repositoryListPresenter hasSelection and: [packageListPresenter selections size = 1]). ^true].
	(#(#'compareAncestor') includes: command) ifTrue: [
		aCommandQuery isEnabled: (packageListPresenter selections size = 1 and: [ancestorListPresenter hasSelection]). ^true].
	(#(#'browseMethodHistory' #'browseImplementors' #'browseSenders' #'fileOutMethod') includes: command) ifTrue: [
		aCommandQuery isEnabled: methodListPresenter selections size = 1. ^true].
	(#(#'inspectGlobal' #'browseGlobalReferences') includes: command) ifTrue: [aCommandQuery isEnabled: globalsPresenter selections size = 1. ^true].
	(#(#'removeGlobals') includes: command) ifTrue: [aCommandQuery isEnabled: globalsPresenter selections notEmpty. ^true].
	(#(#'fileOutDictionary' ) includes: command) ifTrue: [aCommandQuery isEnabled: dictionaryListPresenter selections size = 1. ^true].
	(#(#'setHomeDictionary') includes: command) ifTrue: [aCommandQuery isEnabled: (dictionaryListPresenter selections size = 1 and: [dictionaryListPresenter selection value not]). ^true].
	(#(#'runMethodTests') includes: command) ifTrue: [aCommandQuery isEnabled: (methodListPresenter selections notEmpty and: [methodListPresenter selections first at: 3]). ^true].
	(#(#'loadLatestVersion') includes: command) ifTrue: [
		aCommandQuery isEnabled: (packageListPresenter selections notEmpty and: [packageListPresenter selections allSatisfy: [:each | each key beginsWith: 'ConfigurationOf']]). ^true].
	(#(#'browseClassReferences' #'fileOutClass' #'addSubclass' #'addMissingAccessors' #'removeClass' #'removePriorVersions') includes: command) ifTrue: [
		aCommandQuery isEnabled: self selectedClasses size == 1. ^true.
	].
	(#(#'runClassTests') includes: command) ifTrue: [aCommandQuery isEnabled: selectedClassesAreTestCases. ^true].
	(#(#'browseSelectedClass') includes: command) ifTrue: [aCommandQuery isEnabled: self isClassSelectedInEditor. ^true].

	(command == #historyBack) ifTrue: [aCommandQuery isEnabled: self hasCommandHistoryBack. ^true].
	(command == #historyForward) ifTrue: [aCommandQuery isEnabled: self hasCommandHistoryForward. ^true].

	(command == #'setEnvironment0' and: [environment == 0]) ifTrue: [aCommandQuery isChecked: true. ^true].
	(command == #'setEnvironment1' and: [environment == 1]) ifTrue: [aCommandQuery isChecked: true. ^true].
	(command == #'setEnvironment2' and: [environment == 2]) ifTrue: [aCommandQuery isChecked: true. ^true].

	^super queryCommand: aCommandQuery.
!

savePackage

	| package string array dict stream |
	self rowanFixMe. "Eventually, this would be nice to have." 
	true ifTrue:[^MessageBox notify: 'This functionality is not available. Commit your changes at the project level.'].
	package := packageListPresenter selections first.
	string := self updateCommand: 'uniqueVersionName' , Character tab asString , package key.
	string = 'uniqueVersionName' ifFalse: [self error: 'Unrecognized response'].
	string := readStream nextLine.
	array := ancestorListPresenter list.
	array := array isEmpty 
		ifTrue: [#('' '' '' '')]
		ifFalse: [array first].
	dict := Dictionary new
		at: #'httpPassword'		put: '';
		at: #'httpUser'			put: '';
		at: #'name' 			put: package key;
		at: #'isModified'			put: package value;
		at: #'nextVersionName'	put: string;
		at: #'priorVersionName'	put: (array at: 2);
		at: #'versionMessage'		put: (array at: 4);
		at: #'repositoryList'		put: repositoryListPresenter list;
		at: #'repository'			put: (repositoryListPresenter selectionIfNone: [repositoryListPresenter model last]);
		yourself.
	(RowanSavePackageDialog showModalOn: dict) isNil ifTrue: [^self].
	stream := (WriteStream on: String new)
		nextPutAll: 'savePackage'; tab;
		nextPutAll: package key; tab;
		nextPutAll: ((dict at: #'repository') at: 2); tab;
		nextPutAll: (dict at: #'versionName'); tab;
		nextPutAll: (dict at: #'httpUser'); tab;
		nextPutAll: (dict at: #'httpPassword'); lf;
		nextPutAll: ((dict at: #'versionMessage') reject: [:char | char = Character cr]); lf;
		nextPut: $%; lf;
		nextPutAll: self requestString;
		yourself.
	self updateCommand: stream contents.
!

updateMethod
	| gsMethod isReadOnly listModel methodSourceLabel newSource warnings x |
	methodSourcePresenter view cancelCallTip.
	gsMethod := GsMethod fromStream: readStream session: gciSession.
	isReadOnly := gsMethod isReadOnly.	"current user has write permission for the class"
	newSource := gsMethod source.
	methodSourcePresenter view isModified
		ifTrue: 
			[newSource = methodSource ifTrue: [^self].
			(MessageBox confirm: 'Copy changes to clipboard?' caption: 'Method has unsaved changes!!')
				ifTrue: [methodSourcePresenter value copyToClipboard]].
	methodSource := newSource.
	methodSourcePresenter value: methodSource.
	unimplementedSelectors := gsMethod unimplementedSelectors.
	stepPoints := gsMethod stepPoints.
	breakPoints := gsMethod breakPoints.
	self updateMethodStepPoints.
	methodSourcePresenter view
		backcolor: JadeTextStyles default colorForNoEdits;
		isModified: false;
		isReadOnly: isReadOnly;
		yourself.
	(overrideListPresenter list notEmpty
		and: [overrideListPresenter selectionOrNil ~= overrideListPresenter list last])
			ifTrue: 
				[methodSourcePresenter view
					backcolor: nil;
					isReadOnly: true;
					yourself].
	((methodCategory := gsMethod category) notEmpty and: [self isCategoriesTabSelected])
		ifTrue: 
			[| fullList selections index newName |
			fullList := categoryListPresenter list.
			selections := categoryListPresenter selections.
			0 < (index := fullList indexOf: methodCategory)
				ifTrue: 
					[fullList at: index put: (newName := ' ' , methodCategory).
					categoryListPresenter list: fullList.
					0 < (index := selections indexOf: methodCategory)
						ifTrue: 
							[selections at: index put: newName.
							categoryListPresenter selections: selections].
					categoryListPresenter view invalidate]].
	listModel := (textAreaTabs subViews detect: [:each | each class == TabViewXP]) model.
	originalSourceLabel
		ifNil: [originalSourceLabel := listModel detect: [:each | each text = 'Original Source']].
	methodSourceLabel := listModel detect: [:each | each text = 'Method Source'].
	(x := gsMethod originalSource) isEmpty
		ifTrue: [listModel remove: originalSourceLabel ifAbsent: []]
		ifFalse: 
			[(listModel includes: originalSourceLabel)
				ifFalse: [listModel add: originalSourceLabel before: methodSourceLabel].
			originalSourcePresenter value: x].
	(warnings := gsMethod warnings) notEmpty
		ifTrue: [MessageBox warning: warnings caption: 'Jade Compile Warning']!

updateSelector
	| gsMethod isReadOnly listModel methodSourceLabel newSource warnings x |
	methodSourcePresenter view cancelCallTip.
	gsMethod := GsMethod fromStream: readStream session: gciSession.
	isReadOnly := gsMethod isReadOnly.	"current user has write permission for the class"
	newSource := gsMethod source.
	methodSourcePresenter view isModified
		ifTrue: 
			[newSource = methodSource ifTrue: [^self].
			(MessageBox confirm: 'Copy changes to clipboard?' caption: 'Method has unsaved changes!!')
				ifTrue: [methodSourcePresenter value copyToClipboard]].
	methodSource := newSource.
	methodSourcePresenter value: methodSource.
	unimplementedSelectors := gsMethod unimplementedSelectors.
	stepPoints := gsMethod stepPoints.
	breakPoints := gsMethod breakPoints.
	self updateMethodStepPoints.
	methodSourcePresenter view
		backcolor: JadeTextStyles default colorForNoEdits;
		isModified: false;
		isReadOnly: isReadOnly;
		yourself.
	(overrideListPresenter list notEmpty
		and: [overrideListPresenter selectionOrNil ~= overrideListPresenter list last])
			ifTrue: 
				[methodSourcePresenter view
					backcolor: nil;
					isReadOnly: true;
					yourself].
	((methodCategory := gsMethod category) notEmpty and: [self isCategoriesTabSelected])
		ifTrue: 
			[| fullList selections index newName |
			fullList := categoryListPresenter list.
			selections := categoryListPresenter selections.
			0 < (index := fullList indexOf: methodCategory)
				ifTrue: 
					[fullList at: index put: (newName := ' ' , methodCategory).
					categoryListPresenter list: fullList.
					0 < (index := selections indexOf: methodCategory)
						ifTrue: 
							[selections at: index put: newName.
							categoryListPresenter selections: selections].
					categoryListPresenter view invalidate]].
	listModel := (textAreaTabs subViews detect: [:each | each class == TabViewXP]) model.
	originalSourceLabel
		ifNil: [originalSourceLabel := listModel detect: [:each | each text = 'Original Source']].
	methodSourceLabel := listModel detect: [:each | each text = 'Method Source'].
	(x := gsMethod originalSource) isEmpty
		ifTrue: [listModel remove: originalSourceLabel ifAbsent: []]
		ifFalse: 
			[(listModel includes: originalSourceLabel)
				ifFalse: [listModel add: originalSourceLabel before: methodSourceLabel].
			originalSourcePresenter value: x].
	(warnings := gsMethod warnings) notEmpty
		ifTrue: [MessageBox warning: warnings caption: 'Jade Compile Warning']! !
!JadeSystemBrowserPresenter categoriesFor: #browseMethodsAndSelect:!menu handlers!public! !
!JadeSystemBrowserPresenter categoriesFor: #browseMethodsAndSelect:type:!menu handlers!public! !
!JadeSystemBrowserPresenter categoriesFor: #onViewOpened!menus!overrides!public! !
!JadeSystemBrowserPresenter categoriesFor: #packageTabName!menus!overrides!public! !
!JadeSystemBrowserPresenter categoriesFor: #queryCommand:!event handlers!overrides!public! !
!JadeSystemBrowserPresenter categoriesFor: #savePackage!menu handlers!public! !
!JadeSystemBrowserPresenter categoriesFor: #updateMethod!public!updating! !
!JadeSystemBrowserPresenter categoriesFor: #updateSelector!public!updating! !

!JadeTextDocument methodsFor!

aboutJadeite
	JadeLoginShell aboutJadeite!

jadeBrowseClasses

	gciSession hasServer ifTrue: [
		^RowanSystemBrowser showOnSession: gciSession.
	].
	MessageBox
		warning: 'Server initialization failed at login.'
		caption: 'Unable to Open Browser'.
! !
!JadeTextDocument categoriesFor: #aboutJadeite!private! !
!JadeTextDocument categoriesFor: #jadeBrowseClasses!Jade!private! !

!JadeToolsToolBarPresenter methodsFor!

browseClasses

	RowanSystemBrowser showOnSession: gciSession.
! !
!JadeToolsToolBarPresenter categoriesFor: #browseClasses!public! !

!JadeTranscript methodsFor!

methodsChanged24

| string result |
	
	result := gciSession executeString: '| result methods|
		result := MethodVersionHistory uniqueInstance methodsNewerThan: (DateTime now subtractDays: 1 ).
		methods := IdentitySet new.
		result do: [:e | e asCompiledMethod ifNotNil: [:m | methods add: m]].
		methods asArray'.
(JadeMethodListBrowser showOnSession: self gciSession) primaryPresenter
		browseMethods: result;
		yourself.
	"JadeInspector showOn: result session: gciSession."
!

methodsChangedDays

| string result |
	(string := Prompter prompt: 'Enter number of days:') isNil ifTrue: [^self].	
	result := gciSession executeString: '| result methods|
		result := MethodVersionHistory uniqueInstance methodsNewerThan: (DateTime now subtractDays: ' , string , ' ).
		methods := IdentitySet new.
		result do: [:e | e asCompiledMethod ifNotNil: [:m | methods add: m]].
		methods asArray'.
	(JadeMethodListBrowser showOnSession: self gciSession) primaryPresenter
		browseMethods: result;
		yourself.

!

openRowanProjectList
	^(RowanProjectListShell showOnSession: self gciSession) primaryPresenter
		browseProjects;
		yourself! !
!JadeTranscript categoriesFor: #methodsChanged24!event handling!public! !
!JadeTranscript categoriesFor: #methodsChangedDays!event handling!public! !
!JadeTranscript categoriesFor: #openRowanProjectList!public!rowan! !

!JadeTreeMethodListPresenter methodsFor!

browseMethodsFromString: aString
	| list |

	"self hasTreeListSelection ifFalse: [self addTreeListRoot]."

	list := RowanMethodDefinition
		listFromString: aString
		session: self gciSession.
	methodListPresenter list: list asSortedCollection.
	list notEmpty ifTrue: [
		"methodListPresenter selectFirstMethod."
	].!

browseMethodsFromString: aString methodName: methodName
	| list node |

	self hasTreeListSelection ifFalse: [node := self addTreeListRoot: methodName type: #references].

	list := RowanMethodDefinition
		listFromString: aString
		session: self gciSession.
	methodListPresenter list: list asSortedCollection.
	list notEmpty ifTrue: [
		methodListPresenter selectFirstMethod.
	].
	node isNil ifTrue: [^self].

	treeMethodsMap at: node put: list asSortedCollection.

	treeMethodsPresenter selection: node
!

browseMethodsFromString: aString methodName: methodName type: browseType
	| list  node |

	node := self hasTreeListSelection 
			ifFalse: [self addTreeListRoot: methodName type: browseType] 
			ifTrue: [treeMethodsPresenter model add: (self getLabelForMethod: methodName type: browseType) asChildOf: treeMethodsPresenter selection.].

	list := RowanMethodDefinition
		listFromString: aString
		session: self gciSession.
	methodListPresenter list: list asSortedCollection.
	list notEmpty ifTrue: [
		"methodListPresenter selectFirstMethod."
	].

	treeMethodsMap at: node put: list asSortedCollection.

	treeMethodsPresenter selection: node!

onDropMethodsTree: aDragDropSession

	(aDragDropSession operation = #move) ifFalse: [^self].

	(aDragDropSession suggestedSource class = GsMethod2) ifTrue: [^self dropGsMethod: aDragDropSession].

	^self dropNode: aDragDropSession
! !
!JadeTreeMethodListPresenter categoriesFor: #browseMethodsFromString:!public! !
!JadeTreeMethodListPresenter categoriesFor: #browseMethodsFromString:methodName:!public! !
!JadeTreeMethodListPresenter categoriesFor: #browseMethodsFromString:methodName:type:!public! !
!JadeTreeMethodListPresenter categoriesFor: #onDropMethodsTree:!public! !

!MCClassDefinition methodsFor!

initialize: aStream
	| i j |
	definition := (aStream upTo: Character lf) copyReplaceAll: Character cr asString
				with: Character cr asString , Character lf asString.
	className := (definition subStrings includes: 'rwSubclass:')
				ifTrue: [(definition subStrings at: 3) copyWithoutAll: #($')]
				ifFalse: 
					[i := definition indexOf: $#.
					j := definition indexOf: Character cr.
					definition copyFrom: i + 1 to: j - 1]! !
!MCClassDefinition categoriesFor: #initialize:!public! !

!MCPatchBrowser methodsFor!

browseChangedThing
	| selection  shell |
	selection := operationListPresenter selectionOrNil.
	selection isNil ifTrue: [^MessageBox notify: 'Nothing to browse'].
	selection isRemoval ifTrue:[^MessageBox notify: 'Cannot browse a removed item'].
	shell := RowanSystemBrowser showOnSession: self gciSession.
	shell selectClass: selection className selector: selection selector asSymbol!

operationSelected

	| operation |
	leftTextPresenter 		value: ''.
	leftMemoPresenter	value: ''.
	rightTextPresenter	value: ''.
	rightMemoPresenter	value: ''.
	operationListPresenter hasSelection ifFalse: [^self].
	operation := operationListPresenter selection.
	leftTextPresenter 		value: operation obsoletionText.
	leftMemoPresenter	value: operation obsoletionMemo.
	rightTextPresenter	value: operation modificationText.
	rightMemoPresenter	value: operation modificationMemo.
	operation obsoletionMemoMarkers do: [:each | 
		leftMemoPresenter view addMarkerType: each key at: each value.
	].
	operation modificationMemoMarkers do: [:each |
		rightMemoPresenter view addMarkerType: each key at: each value.
	].
! !
!MCPatchBrowser categoriesFor: #browseChangedThing!public! !
!MCPatchBrowser categoriesFor: #operationSelected!public! !

!MethodListPresenter methodsFor!

browseClass

	| selection browserClass |
	selection := methodListPresenter selection.
	browserClass := Smalltalk at: #RowanSystemBrowser.		"Avoid circular dependencies on load order"
	(browserClass showOnSession: self gciSession)
		selectClass: selection gsClass name
		selector: selection name.
!

browseMethodsContaining

	| string |
	(string := Prompter prompt: 'Enter substring:') isNil ifTrue: [^self].
	(JadeMethodListBrowser showOnSession: self gciSession) primaryPresenter browseMethodsContaining: string.
! !
!MethodListPresenter categoriesFor: #browseClass!public! !
!MethodListPresenter categoriesFor: #browseMethodsContaining!public! !

!MethodSourcePresenter methodsFor!

fileSave
		"Answer whether the save succeeded (false means to stay on the window and cancel any attempt to leave)"

	| user theClass newSelector category string stream list warnings errors index a b c methodExists line newOop |

	(theClass := gsMethod behavior) isNil ifTrue: [^true].
	newSelector := self newSelector.
	currentSelector = newSelector ifFalse: [
		methodExists := gciSession
			serverPerform: #'class:includesSelector:'
			with: theClass
			with: newSelector.
		methodExists ifTrue: [
			(MessageBox confirm: 'Replace method?' caption: 'Method already exists!!') ifFalse: [^self].
		].
	].
	user := self trigger: #'needUser'.
	(category := gsMethod category) isNil ifTrue: [self error: 'We need a method category!!?'].

	string := gciSession
		serverPerform: #'compileMethod:behavior:user:inCategory:'
		with: documentPresenter value replaceCrLfWithLf
		with: theClass 
		with: user 
		with: category.

	stream := ReadStream on: string.
	(line := stream nextLine) notEmpty ifTrue: [
		| pieces |
		pieces := line subStrings: Character tab.
		newOop := (pieces at: 1) asNumber. 
		newSelector := pieces at: 2.
		documentPresenter isModified: false.
		self 
			trigger: #'savedMethod:inClass:' 
			with: newSelector
			with: theClass.
	].
	newOop isNil ifFalse:[
		parentPresenter updateSaveMethodOop: newOop].
	(list := stream upToEnd subStrings: Character lf) isEmpty ifTrue: [^true].
	warnings := list select: [:each | each beginsWith: 'WARNING:'].
	warnings := warnings collect: [:each | each copyFrom: 10 to: each size].
	warnings notEmpty ifTrue: [
		ChoicePrompter
			choices: warnings
			caption: 'Compile warnings'.
	].
	errors := list select: [:each | each beginsWith: 'ERROR:'].
	errors isEmpty ifTrue: [^true].
	list := errors first subStrings: Character tab.
	string := documentPresenter value replaceCrLfWithLf.
	index := (list at: 3) asNumber - 1.
	a := (string copyFrom: 1 to: index) "replaceLfWithCrLf".
	b := (list at: 4) "replaceLfWithCrLf".
	c := (string copyFrom: index + 1 to: string size) "replaceLfWithCrLf".
	index := a size + 1.
	string := a , b , c.
	documentPresenter value: string.
	documentPresenter view
		selectionStart: index 
		length: b size.
	^false.
! !
!MethodSourcePresenter categoriesFor: #fileSave!public! !

!Object methodsFor!

rowanFixMe

	"do nothing. Used for marking to-do items 
	during Rowan Development"! !
!Object categoriesFor: #rowanFixMe!public!testing! !

!Presenter methodsFor!

updateReady: aBlock

	aBlock value

	!

updateSelectionsFor: browserUpdate

	browserUpdate updates do:[:update | self updateSelectionsForUpdate: update].

	!

updateSelectionsForUpdate: update

	"do nothing for most presenters"

	! !
!Presenter categoriesFor: #updateReady:!public!rowan! !
!Presenter categoriesFor: #updateSelectionsFor:!public!rowan! !
!Presenter categoriesFor: #updateSelectionsForUpdate:!public!rowan! !

!RowanCommandResult methodsFor!

classCategoryUpdate: presenter
	!

classCommentUpdate: presenter
	
	!

classDefinitionUpdate: presenter
	!

classesHierarchyUpdate: presenter
!

classesUpdate: presenter
	!

classHierarchyUpdate: presenter
	!

classMethodsUpdate: presenter
	!

classUpdate: presenter
	!

dictionaryUpdate: presenter
	!

globalsUpdate: presenter!

methodFilterUpdate: presenter
	!

methodsUpdate: presenter
	!

packagesUpdate: presenter!

projectPackagesUpdate: presenter!

projectSelectionUpdate: aPresenter
!

projectsUpdate: aPresenter!

superclassListUpdate: presenter
	!

updateClassCategorySelectionsFor: presenter!

updateClassHierarchySelectionFor: presenter!

updateClassSelectionFor: presenter!

updateDictionarySelectionsFor: presenter
	!

updateMethodFilterSelectionFor: presenter!

updateMethodSelectionFor: presenter!

updatePackageSelectionsFor: presenter
	!

updateSelectorFor: presenter!

updateSuperclassSelectionFor: presenter! !
!RowanCommandResult categoriesFor: #classCategoryUpdate:!public!updating! !
!RowanCommandResult categoriesFor: #classCommentUpdate:!public!updating! !
!RowanCommandResult categoriesFor: #classDefinitionUpdate:!public!updating! !
!RowanCommandResult categoriesFor: #classesHierarchyUpdate:!public!updating! !
!RowanCommandResult categoriesFor: #classesUpdate:!public!updating! !
!RowanCommandResult categoriesFor: #classHierarchyUpdate:!public!updating! !
!RowanCommandResult categoriesFor: #classMethodsUpdate:!public!updating! !
!RowanCommandResult categoriesFor: #classUpdate:!public!updating! !
!RowanCommandResult categoriesFor: #dictionaryUpdate:!public!updating! !
!RowanCommandResult categoriesFor: #globalsUpdate:!public!updating! !
!RowanCommandResult categoriesFor: #methodFilterUpdate:!public!updating! !
!RowanCommandResult categoriesFor: #methodsUpdate:!public!updating! !
!RowanCommandResult categoriesFor: #packagesUpdate:!public!updating! !
!RowanCommandResult categoriesFor: #projectPackagesUpdate:!public!updating! !
!RowanCommandResult categoriesFor: #projectSelectionUpdate:!public!updating! !
!RowanCommandResult categoriesFor: #projectsUpdate:!public!updating! !
!RowanCommandResult categoriesFor: #superclassListUpdate:!public!updating! !
!RowanCommandResult categoriesFor: #updateClassCategorySelectionsFor:!public!updating! !
!RowanCommandResult categoriesFor: #updateClassHierarchySelectionFor:!public!updating! !
!RowanCommandResult categoriesFor: #updateClassSelectionFor:!public!updating! !
!RowanCommandResult categoriesFor: #updateDictionarySelectionsFor:!public!updating! !
!RowanCommandResult categoriesFor: #updateMethodFilterSelectionFor:!public!updating! !
!RowanCommandResult categoriesFor: #updateMethodSelectionFor:!public!updating! !
!RowanCommandResult categoriesFor: #updatePackageSelectionsFor:!public!updating! !
!RowanCommandResult categoriesFor: #updateSelectorFor:!public!updating! !
!RowanCommandResult categoriesFor: #updateSuperclassSelectionFor:!public!updating! !

!RowanGsMethod methodsFor!

printOn: aStream
	super printOn: aStream.
	aStream cr.
	self class allInstVarNames do: 
			[:instVarName |
			aStream
				nextPutAll: instVarName;
				nextPutAll: ' - ';
				nextPutAll: (self instVarNamed: instVarName) printString;
				cr]! !
!RowanGsMethod categoriesFor: #printOn:!printing!public! !

!RowanMethodDefinition methodsFor!

methodDefinitionService
	^methodDefinitionService ifNil: [methodDefinitionService := RowanMethodService on: gciSession]! !
!RowanMethodDefinition categoriesFor: #methodDefinitionService!public!services! !

!STON class methodsFor!

fromStream: readStream
	^ (self reader on: readStream) next
!

fromString: string
	^self fromStream: string readStream!

jsonWriter
	^STONWriter new
		jsonMode: true;
		yourself!

listClass
	^Array!

mapClass
	^Dictionary!

put: object asJsonOnStream: stream
	(self jsonWriter on: stream) nextPut: object!

put: object asJsonOnStreamPretty: stream
	(self jsonWriter on: stream)
		prettyPrint: true;
		nextPut: object!

put: object onStream: stream
	(self writer on: stream) nextPut: object
!

put: object onStreamPretty: stream
	(self writer on: stream)
		prettyPrint: true;
		nextPut: object!

reader
	^STONReader new!

toJsonString: object
	^String streamContents: [:stream | self put: object asJsonOnStream: stream]!

toJsonStringPretty: object
	^String streamContents: [:stream | self put: object asJsonOnStreamPretty: stream]!

toString: object
	^String streamContents: [:stream | self put: object onStream: stream]!

toStringPretty: object
	^String streamContents: [:stream | self put: object onStreamPretty: stream]!

writer
	^STONWriter new! !
!STON class categoriesFor: #fromStream:!public! !
!STON class categoriesFor: #fromString:!public! !
!STON class categoriesFor: #jsonWriter!public! !
!STON class categoriesFor: #listClass!public! !
!STON class categoriesFor: #mapClass!public! !
!STON class categoriesFor: #put:asJsonOnStream:!public! !
!STON class categoriesFor: #put:asJsonOnStreamPretty:!public! !
!STON class categoriesFor: #put:onStream:!public! !
!STON class categoriesFor: #put:onStreamPretty:!public! !
!STON class categoriesFor: #reader!public! !
!STON class categoriesFor: #toJsonString:!public! !
!STON class categoriesFor: #toJsonStringPretty:!public! !
!STON class categoriesFor: #toString:!public! !
!STON class categoriesFor: #toStringPretty:!public! !
!STON class categoriesFor: #writer!public! !

"End of package definition"!

